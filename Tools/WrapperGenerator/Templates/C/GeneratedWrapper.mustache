#pragma once


{{> Header }}


#pragma region Generated Includes

{{# includes }}
{{> Include }}
{{/ includes }}

#pragma endregion Generated Includes

/*
    Callback queue designed to push callbacks onto the main thread using the emscripten api.
    This works because emscriptens threads are just web workers, which allows us to push messages to different workers.

    This is implemented to work around the limitation of callbacks needing to fire on the same thread they were created on.
*/
#pragma region Emscripten Callback Queue

#if CSP_WASM
#include <emscripten.h>
#include <emscripten/proxying.h>
#include <emscripten/threading.h>
#include <pthread.h>
#include <tuple>

static em_proxying_queue* ProxyQueue = nullptr;
static pthread_t MainThread = 0;

// Creates an emscripten queue and sets the main thread if we haven't already initialized.
void Emscripten_InitializeProxyQueue()
{
    if (ProxyQueue != nullptr)
    {
        return;
    }

    ProxyQueue = em_proxying_queue_create();
    MainThread = emscripten_main_runtime_thread_id();
}

// Structure to hold the callback and arguments.
template <typename ...T>
struct CallbackData
{
    void (*Callback)(T...);
    std::tuple<T...> Args;
 };

// This function is called internally from emscripten_proxy_sync on the main thread.
template <typename ...T>
static void Emscripten_CallbackWrapper(void* InData) 
{
    auto* Data = static_cast<CallbackData<T...>*>(InData);
    std::apply(Data->Callback, Data->Args);
}

// Function that will push the callback to the main thread if we are not on it.
template <typename ...T>
static void Emscripten_CallbackOnThread(void (*Callback)(T...), T... Args) 
{
    bool OnMainThread = pthread_equal(pthread_self(), emscripten_main_runtime_thread_id());
    if (OnMainThread)
    {
        // We're on the main thread already, just call normally
        Callback(Args...);
    }
    else
    {
        Emscripten_InitializeProxyQueue();

        // Pack our data and send to the emscripten queue.
        CallbackData<T...> Data{Callback, std::make_tuple(Args...)};
        emscripten_proxy_sync(ProxyQueue, MainThread, Emscripten_CallbackWrapper<T...>, static_cast<void*>(&Data));
    }
}
#endif
#pragma endregion Emscripten Callback Queue

// Generic callback function which will either call the callback directly, or, 
// if we're on wasm, push to the main thread if we're not on the main thread.
template <typename ...T>
static void CallCallback(void (*Callback)(T...), T... Args)
{
#ifdef CSP_WASM
    Emscripten_CallbackOnThread(Callback, Args...);
#else
    Callback(Args...);
#endif
}

extern "C"
{
    typedef struct {
        const void* Pointer;
        bool OwnsOwnData;
    } NativePointer;

    #pragma region Global Functions

{{# functions }}
    {{> GlobalFunction }}

{{/ functions }}
    #pragma endregion Global Functions


    #pragma region Classes

{{# classes }}
    {{> Class }}

{{/ classes }}
    #pragma endregion Classes


    #pragma region Templates

{{# templates }}
    {{> Template }}

{{/ templates }}
    #pragma endregion Templates
}