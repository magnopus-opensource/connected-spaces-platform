{% from 'helpers.jinja2' import are_values_notequal %}

// Include the generated C interface so it gets compiled
#include "../../Tools/WrapperGenerator/Output/C/generated_wrapper.h"

#include "CSP/Memory/DllAllocator.h"

#include "Memory/Memory.h"

#include <cassert>
#include <cmath>
#include <limits>

#include "generated_exports.h"


namespace csp {
    // Helper function to free allocated memory from wrappers
    CSP_API void Free(void* Pointer) {
        csp::memory::DllFree(Pointer);
    }

    // Helper function to check floats for equality using dynamic tolerance value
    inline bool FloatsAreEqual(double A, double B) {
        auto Tolerance = std::fmax(std::fabs(A), std::fabs(B)) * 1E-8;

        return (std::fabs(A - B) <= Tolerance);
    }


    /********************************/
    /*       Global functions       */
    /********************************/

    /// Return types

    // Primitives

    {% for p in config.primitives %}
        // Return {{ p.type }} min value by value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_ReturnValue_min() {
            return {{ p.min }};
        }

        // Return {{ p.type }} max value by value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_ReturnValue_max() {
            return {{ p.max }};
        }

        // Return {{ p.type }} min value by pointer
        {{ p.type }}* GlobalFunctions_Primitives_{{ p.type }}_ReturnPointer_min() {
            static {{ p.type }} Value = {{ p.min }};

            return &Value;
        }

        // Return {{ p.type }} max value by pointer
        {{ p.type }}* GlobalFunctions_Primitives_{{ p.type }}_ReturnPointer_max() {
            static {{ p.type }} Value = {{ p.max }};

            return &Value;
        }

        // Return {{ p.type }} min value by const pointer
        const {{ p.type }}* GlobalFunctions_Primitives_{{ p.type }}_ReturnConstPointer_min() {
            static {{ p.type }} Value = {{ p.min }};

            return &Value;
        }

        // Return {{ p.type }} max value by const pointer
        const {{ p.type }}* GlobalFunctions_Primitives_{{ p.type }}_ReturnConstPointer_max() {
            static {{ p.type }} Value = {{ p.max }};

            return &Value;
        }

        // Return {{ p.type }} min value by reference
        {{ p.type }}& GlobalFunctions_Primitives_{{ p.type }}_ReturnReference_min() {
            static {{ p.type }} Value = {{ p.min }};

            return Value;
        }

        // Return {{ p.type }} max value by reference
        {{ p.type }}& GlobalFunctions_Primitives_{{ p.type }}_ReturnReference_max() {
            static {{ p.type }} Value = {{ p.max }};

            return Value;
        }

        // Return {{ p.type }} min value by const reference
        const {{ p.type }}& GlobalFunctions_Primitives_{{ p.type }}_ReturnConstReference_min() {
            static {{ p.type }} Value = {{ p.min }};

            return Value;
        }

        // Return {{ p.type }} max value by const reference
        const {{ p.type }}& GlobalFunctions_Primitives_{{ p.type }}_ReturnConstReference_max() {
            static {{ p.type }} Value = {{ p.max }};

            return Value;
        }
    {% endfor %}


    // String

    // Return string by value
    csp::common::String GlobalFunctions_String_ReturnValue(){
        return "{{ config.string_value }}";
    }

    // Return string by const reference
    const csp::common::String& GlobalFunctions_String_ReturnConstReference() {
        static csp::common::String Value = "{{ config.string_value }}";

        return Value;
    }


    // Classes

    // Return class by value
    MyClass GlobalFunctions_MyClass_ReturnValue() {
        return MyClass({{ config.class_int_value_first }});
    }
    
    // Return class by pointer
    MyClass* GlobalFunctions_MyClass_ReturnPointer() {
        static MyClass Instance({{ config.class_int_value_first }});

        return &Instance;
    }

    // Return class by const pointer
    const MyClass* GlobalFunctions_MyClass_ReturnConstPointer() {
        static MyClass Instance({{ config.class_int_value_first }});

        return &Instance;
    }

    // Return class by reference
    MyClass& GlobalFunctions_MyClass_ReturnReference() {
        static MyClass Instance({{ config.class_int_value_first }});

        return Instance;
    }

    // Return class by const reference
    const MyClass& GlobalFunctions_MyClass_ReturnConstReference() {
        static MyClass Instance({{ config.class_int_value_first }});

        return Instance;
    }


    /// Parameter types

    // Primitives

    {% for p in config.primitives %}
        // Pass {{ p.type }} min value by value
        void GlobalFunctions_Primitives_{{ p.type }}_PassValue_min({{ p.type }} Value) {
            if ({{ are_values_notequal(p.use_epsilon, "Value", p.min) }}) {
                throw std::invalid_argument("Value");
            }
        }

        // Pass {{ p.type }} max value by value
        void GlobalFunctions_Primitives_{{ p.type }}_PassValue_max({{ p.type }} Value) {
            if ({{ are_values_notequal(p.use_epsilon, "Value", p.max) }}) {
                throw std::invalid_argument("Value");
            }
        }

        // Get {{ p.type }} min value via out parameter
        void GlobalFunctions_Primitives_{{ p.type }}_PassOut_min(CSP_OUT {{ p.type }}& OutValue) {
            OutValue = {{ p.min }};
        }

        // Get {{ p.type }} max value via out parameter
        void GlobalFunctions_Primitives_{{ p.type }}_PassOut_max(CSP_OUT {{ p.type }}& OutValue) {
            OutValue = {{ p.max }};
        }

        // Get {{ p.type }} min and max values via out parameters
        void GlobalFunctions_Primitives_{{ p.type }}_PassOut_minmax(
            CSP_OUT {{ p.type }}& OutMinValue,
            CSP_OUT {{ p.type }}& OutMaxValue
        ) {
            OutMinValue = {{ p.min }};
            OutMaxValue = {{ p.max }};
        }

        // Get {{ p.type }} min value via out parameter and return {{ p.type }} max value by value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_PassOut_min_ReturnValue_max(
            CSP_OUT {{ p.type }}& OutValue
        ) {
            OutValue = {{ p.min }};

            return {{ p.max }};
        }

        // Get {{ p.type }} min and max values via out parameters and return {{ p.type }} min value by value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_PassOut_minmax_ReturnValue_min(
            CSP_OUT {{ p.type }}& OutMinValue,
            CSP_OUT {{ p.type }}& OutMaxValue
        ) {
            OutMinValue = {{ p.min }};
            OutMaxValue = {{ p.max }};

            return {{ p.min }};
        }

        // Pass {{ p.type }} min value and get max value via in-out parameter
        void GlobalFunctions_Primitives_{{ p.type }}_PassInOut_minmax(CSP_IN_OUT {{ p.type }}& InOutValue) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue", p.min) }}) {
                throw std::invalid_argument("InOutValue");
            }

            InOutValue = {{ p.max }};
        }

        // Pass {{ p.type }} min value and get max value via in-out parameter, and pass {{ p.type }} max value and get
        // min value via another in-out parameter
        void GlobalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin(
            CSP_IN_OUT {{ p.type }}& InOutValue1,
            CSP_IN_OUT {{ p.type }}& InOutValue2
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue1", p.min) }}) {
                throw std::invalid_argument("InOutValue1");
            }

            if ({{ are_values_notequal(p.use_epsilon, "InOutValue2", p.max) }}) {
                throw std::invalid_argument("InOutValue2");
            }

            InOutValue1 = {{ p.max }};
            InOutValue2 = {{ p.min }};
        }

        // Pass {{ p.type }} min value and get max value via in-out-parameter, and return {{ p.type }} max value by
        // value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_ReturnValue_max(
            CSP_IN_OUT {{ p.type }}& InOutValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue", p.min) }}) {
                throw std::invalid_argument("InOutValue");
            }

            InOutValue = {{ p.max }};

            return {{ p.max }};
        }

        // Pass {{ p.type }} min value and get max value via in-out-parameter, pass {{ p.type }} max value and get min
        // value via another in-out parameter, and return {{ p.type }} max value by value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin_ReturnValue_min(
            CSP_IN_OUT {{ p.type }}& InOutValue1,
            CSP_IN_OUT {{ p.type }}& InOutValue2
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue1", p.min) }}) {
                throw std::invalid_argument("InOutValue1");
            }

            if ({{ are_values_notequal(p.use_epsilon, "InOutValue2", p.max) }}) {
                throw std::invalid_argument("InOutValue2");
            }

            InOutValue1 = {{ p.max }};
            InOutValue2 = {{ p.min }};

            return {{ p.min }};
        }

        // Get {{ p.type }} min value via out parameter, and pass {{ p.type }} min value and get max value via in-out
        // parameter
        void GlobalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax(
            CSP_OUT {{ p.type }}& OutValue,
            CSP_IN_OUT {{ p.type }}& InOutMinMaxValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutMinMaxValue", p.min) }}) {
                throw std::invalid_argument("InOutMinMaxValue");
            }

            InOutMinMaxValue = {{ p.max }};
            OutValue = {{ p.min }};
        }

        // Get {{ p.type }} min value via out parameter, pass {{ p.type }} min value and get max value via in-out
        // parameter, and return {{ p.type }} max value by value
        {{ p.type }} GlobalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax_ReturnValue_max(
            CSP_OUT {{ p.type }}& OutValue,
            CSP_IN_OUT {{ p.type }}& InOutMinMaxValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutMinMaxValue", p.min) }}) {
                throw std::invalid_argument("InOutMinMaxValue");
            }

            InOutMinMaxValue = {{ p.max }};
            OutValue = {{ p.min }};

            return {{ p.max }};
        }
    {% endfor %}


    // String

    // Pass string by value
    void GlobalFunctions_String_PassValue(csp::common::String Value) {
        if (Value != "{{ config.string_value }}") {
            throw std::invalid_argument("Value");
        }
    }

    // Pass string by const reference
    void GlobalFunctions_String_PassConstReference(const csp::common::String& Value) {
        if (Value != "{{ config.string_value }}") {
            throw std::invalid_argument("Value");
        }
    }


    // Classes

    // Pass class by value
    void GlobalFunctions_MyClass_PassValue(csp::MyClass Value) {
        if (Value.SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by pointer
    void GlobalFunctions_MyClass_PassPointer(csp::MyClass* Value) {
        if (Value->SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by const pointer
    void GlobalFunctions_MyClass_PassConstPointer(const csp::MyClass* Value) {
        if (Value->SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by reference
    void GlobalFunctions_MyClass_PassReference(csp::MyClass& Value) {
        if (Value.SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by const reference
    void GlobalFunctions_MyClass_PassConstReference(const csp::MyClass& Value) {
        if (Value.SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }


    /********************************/
    /*           Classes            */
    /********************************/

    /// Constructors

    DefaultConstructorClass::DefaultConstructorClass() : SomeValue({{ config.class_int_value_first }}) {

    }

    ParameterConstructorClass::ParameterConstructorClass(int SomeParameter) : SomeValue(SomeParameter) {
        
    }

    ParametersConstructorClass::ParametersConstructorClass(int SomeParameter, bool AnotherParameter)
        : SomeValue(SomeParameter), AnotherValue(AnotherParameter) {
        
    }

    MultipleConstructorsClass::MultipleConstructorsClass() : SomeValue({{ config.class_int_value_first }}) {

    }

    MultipleConstructorsClass::MultipleConstructorsClass(int SomeParameter) : SomeValue(SomeParameter) {

    }


    /// Fields

    // Primitives

    // Pass class and check primitive field values
    void Check_PrimitiveFieldTestClass_Fields(const PrimitiveFieldTestClass& Instance) {
        if (
            {% for p in config.primitives %}
                {%- set field_name -%}
                    Instance.Field{{ loop.index0 }}
                {%- endset -%}

                {{ are_values_notequal(p.use_epsilon, field_name, p.min) }} {{ '||' if not loop.last }}
            {% endfor %}
        ) {
            throw std::invalid_argument("Instance");
        }
    }

    // Pass class and set primitive field values
    void Set_PrimitiveFieldTestClass_Fields(PrimitiveFieldTestClass& Instance) {
        {% for p in config.primitives %}
            Instance.Field{{ loop.index0 }} = {{ p.max }};
        {%- endfor %}
    }


    // String

    // Pass class and check string field values
    void Check_StringFieldTestClass_Field(const StringFieldTestClass& Instance) {
        if (Instance.Field != "{{ config.class_string_value_first }}") {
            throw std::invalid_argument("Instance");
        }
    }

    // Pass class and set string field values
    void Set_StringFieldTestClass_Field(StringFieldTestClass& Instance) {
        Instance.Field = "{{ config.class_string_value_second }}";
    }


    // Classes

    // Pass class and check class field values
    void Check_ClassFieldTestClass_Field(const ClassFieldTestClass& Instance) {
        if (Instance.Field.ACoolInteger != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Instance");
        }
    }

    // Pass class and set class field values
    void Set_ClassFieldTestClass_Field(ClassFieldTestClass& Instance) {
        Instance.Field.ACoolInteger = {{ config.class_int_value_second }};
    }


    /// Functions

    // Return types

    // Primitives

    {% for p in config.primitives %}
        // Return {{ p.type }} min value by value
        {{ p.type }} PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnValue_min() {
            return {{ p.min }};
        }

        // Return {{ p.type }} max value by value
        {{ p.type }} PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnValue_max() {
            return {{ p.max }};
        }

        // Return {{ p.type }} min value by pointer
        {{ p.type }}* PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnPointer_min() {
            Primitive_Field_{{ p.type }} = {{ p.min }};

            return &Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} max value by pointer
        {{ p.type }}* PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnPointer_max() {
            Primitive_Field_{{ p.type }} = {{ p.max }};

            return &Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} min value by const pointer
        const {{ p.type }}* PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnConstPointer_min() {
            Primitive_Field_{{ p.type }} = {{ p.min }};

            return &Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} max value by const pointer
        const {{ p.type }}* PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnConstPointer_max() {
            Primitive_Field_{{ p.type }} = {{ p.max }};

            return &Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} min value by reference
        {{ p.type }}& PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnReference_min() {
            Primitive_Field_{{ p.type }} = {{ p.min }};

            return Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} max value by reference
        {{ p.type }}& PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnReference_max() {
            Primitive_Field_{{ p.type }} = {{ p.max }};

            return Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} min value by const reference
        const {{ p.type }}&
        PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnConstReference_min() {
            Primitive_Field_{{ p.type }} = {{ p.min }};

            return Primitive_Field_{{ p.type }};
        }

        // Return {{ p.type }} max value by const reference
        const {{ p.type }}&
        PrimitiveReturnTestClass::ClassFunctions_Primitives_{{ p.type }}_ReturnConstReference_max() {
            Primitive_Field_{{ p.type }} = {{ p.max }};

            return Primitive_Field_{{ p.type }};
        }
    {% endfor %}


    // String

    // Return string by value
    csp::common::String StringReturnTestClass::ClassFunctions_String_ReturnValue(){
        return "{{ config.string_value }}";
    }

    // Return string by const reference
    const csp::common::String& StringReturnTestClass::ClassFunctions_String_ReturnConstReference() {
        String_Field = "{{ config.string_value }}";

        return String_Field;
    }


    // Classes

    // Return class by value
    MyReallyCoolClass ClassReturnTestClass::ClassFunctions_MyClass_ReturnValue() {
        MyReallyCoolClass Instance;
        Instance.SomeValue = {{ config.class_int_value_first }};

        return Instance;
    }
    
    // Return class by pointer
    MyReallyCoolClass* ClassReturnTestClass::ClassFunctions_MyClass_ReturnPointer() {
        Class_Field.SomeValue = {{ config.class_int_value_first }};

        return &Class_Field;
    }

    // Return class by const pointer
    const MyReallyCoolClass* ClassReturnTestClass::ClassFunctions_MyClass_ReturnConstPointer() {
        Class_Field.SomeValue = {{ config.class_int_value_first }};

        return &Class_Field;
    }

    // Return class by reference
    MyReallyCoolClass& ClassReturnTestClass::ClassFunctions_MyClass_ReturnReference() {
        Class_Field.SomeValue = {{ config.class_int_value_first }};

        return Class_Field;
    }

    // Return class by const reference
    const MyReallyCoolClass& ClassReturnTestClass::ClassFunctions_MyClass_ReturnConstReference() {
        Class_Field.SomeValue = {{ config.class_int_value_first }};

        return Class_Field;
    }


    /// Parameter types

    // Primitives

    {% for p in config.primitives %}
        // Pass {{ p.type }} min value by value
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassValue_min({{ p.type }} Value) {
            if ({{ are_values_notequal(p.use_epsilon, "Value", p.min) }}) {
                throw std::invalid_argument("Value");
            }
        }

        // Pass {{ p.type }} max value by value
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassValue_max({{ p.type }} Value) {
            if ({{ are_values_notequal(p.use_epsilon, "Value", p.max) }}) {
                throw std::invalid_argument("Value");
            }
        }

        {# TODO: Add support for out and in-out params in class methods #}
        {# // Get {{ p.type }} min value via out parameter
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassOut_min(
            CSP_OUT {{ p.type }}& OutValue
        ) {
            OutValue = {{ p.min }};
        }

        // Get {{ p.type }} max value via out parameter
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassOut_max(
            CSP_OUT {{ p.type }}& OutValue
        ) {
            OutValue = {{ p.max }};
        }

        // Get {{ p.type }} min and max values via out parameters
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassOut_minmax(
            CSP_OUT {{ p.type }}& OutMinValue,
            CSP_OUT {{ p.type }}& OutMaxValue
        ) {
            OutMinValue = {{ p.min }};
            OutMaxValue = {{ p.max }};
        }

        // Get {{ p.type }} min value via out parameter and return {{ p.type }} max value by value
        {{ p.type }} PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassOut_min_ReturnValue_max(
            CSP_OUT {{ p.type }}& OutValue
        ) {
            OutValue = {{ p.min }};

            return {{ p.max }};
        }

        // Get {{ p.type }} min and max values via out parameters and return {{ p.type }} min value by value
        {{ p.type }} PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassOut_minmax_ReturnValue_min(
            CSP_OUT {{ p.type }}& OutMinValue,
            CSP_OUT {{ p.type }}& OutMaxValue
        ) {
            OutMinValue = {{ p.min }};
            OutMaxValue = {{ p.max }};

            return {{ p.min }};
        }

        // Pass {{ p.type }} min value and get max value via in-out parameter
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassInOut_minmax(
            CSP_IN_OUT {{ p.type }}& InOutValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue", p.min) }}) {
                throw std::invalid_argument("InOutValue");
            }

            InOutValue = {{ p.max }};
        }

        // Pass {{ p.type }} min value and get max value via in-out parameter, and pass {{ p.type }} max value and get
        // min value via another in-out parameter
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin(
            CSP_IN_OUT {{ p.type }}& InOutValue1,
            CSP_IN_OUT {{ p.type }}& InOutValue2
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue1", p.min) }}) {
                throw std::invalid_argument("InOutValue1");
            }

            if ({{ are_values_notequal(p.use_epsilon, "InOutValue2", p.max) }}) {
                throw std::invalid_argument("InOutValue2");
            }

            InOutValue1 = {{ p.max }};
            InOutValue2 = {{ p.min }};
        }

        // Pass {{ p.type }} min value and get max value via in-out-parameter, and return {{ p.type }} max value by
        // value
        {{ p.type }}
        PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassInOut_minmax_ReturnValue_max(
            CSP_IN_OUT {{ p.type }}& InOutValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue", p.min) }}) {
                throw std::invalid_argument("InOutValue");
            }

            InOutValue = {{ p.max }};

            return {{ p.max }};
        }

        // Pass {{ p.type }} min value and get max value via in-out-parameter, pass {{ p.type }} max value and get min
        // value via another in-out parameter, and return {{ p.type }} max value by value
        {{ p.type }}
        PrimitiveParameterTestClass::
        ClassFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin_ReturnValue_min(
            CSP_IN_OUT {{ p.type }}& InOutValue1,
            CSP_IN_OUT {{ p.type }}& InOutValue2
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutValue1", p.min) }}) {
                throw std::invalid_argument("InOutValue1");
            }

            if ({{ are_values_notequal(p.use_epsilon, "InOutValue2", p.max) }}) {
                throw std::invalid_argument("InOutValue2");
            }

            InOutValue1 = {{ p.max }};
            InOutValue2 = {{ p.min }};

            return {{ p.min }};
        }

        // Get {{ p.type }} min value via out parameter, and pass {{ p.type }} min value and get max value via in-out
        // parameter
        void PrimitiveParameterTestClass::ClassFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax(
            CSP_OUT {{ p.type }}& OutValue,
            CSP_IN_OUT {{ p.type }}& InOutMinMaxValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutMinMaxValue", p.min) }}) {
                throw std::invalid_argument("InOutMinMaxValue");
            }

            InOutMinMaxValue = {{ p.max }};
            OutValue = {{ p.min }};
        }

        // Get {{ p.type }} min value via out parameter, pass {{ p.type }} min value and get max value via in-out
        // parameter, and return {{ p.type }} max value by value
        {{ p.type }}
        PrimitiveParameterTestClass::
        ClassFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax_ReturnValue_max(
            CSP_OUT {{ p.type }}& OutValue,
            CSP_IN_OUT {{ p.type }}& InOutMinMaxValue
        ) {
            if ({{ are_values_notequal(p.use_epsilon, "InOutMinMaxValue", p.min) }}) {
                throw std::invalid_argument("InOutMinMaxValue");
            }

            InOutMinMaxValue = {{ p.max }};
            OutValue = {{ p.min }};

            return {{ p.max }};
        } #}
    {% endfor %}


    // String

    // Pass string by value
    void StringParameterTestClass::ClassFunctions_String_PassValue(csp::common::String Value) {
        if (Value != "{{ config.string_value }}") {
            throw std::invalid_argument("Value");
        }
    }

    // Pass string by const reference
    void StringParameterTestClass::ClassFunctions_String_PassConstReference(const csp::common::String& Value) {
        if (Value != "{{ config.string_value }}") {
            throw std::invalid_argument("Value");
        }
    }


    // Classes

    // Pass class by value
    void ClassParameterTestClass::ClassFunctions_MyClass_PassValue(csp::MyClass Value) {
        if (Value.SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by pointer
    void ClassParameterTestClass::ClassFunctions_MyClass_PassPointer(csp::MyClass* Value) {
        if (Value->SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by const pointer
    void ClassParameterTestClass::ClassFunctions_MyClass_PassConstPointer(const csp::MyClass* Value) {
        if (Value->SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by reference
    void ClassParameterTestClass::ClassFunctions_MyClass_PassReference(csp::MyClass& Value) {
        if (Value.SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }

    // Pass class by const reference
    void ClassParameterTestClass::ClassFunctions_MyClass_PassConstReference(const csp::MyClass& Value) {
        if (Value.SomeValue != {{ config.class_int_value_first }}) {
            throw std::invalid_argument("Value");
        }
    }
} // namespace csp