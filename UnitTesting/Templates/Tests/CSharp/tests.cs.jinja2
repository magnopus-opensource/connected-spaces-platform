{% from 'helpers.jinja2' import assert_are_equal %}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;

using NUnit.Framework;
using UnityEngine;


namespace Csp.Tests {    
    static class UnitTests {
        /********************************/
        /*       Global functions       */
        /********************************/

        /// Return types

        // Primitives
            
        {% for p in config.primitives %}
            {% for x in ['Value', 'ConstPointer', 'ConstReference'] %}
                // Get {{ p.type }} min value by {{ x }}
                [Test]
                public static void GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min() {
                    var result = Global.GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

                    {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
                }

                // Get {{ p.type }} max value by {{ x }}
                [Test]
                public static void GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max() {
                    var result = Global.GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

                    {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
                }
            {% endfor %}

            {# Pointers and references to primitive types are returned as Ref<T> instances #}
            {% for x in ['Pointer', 'Reference'] %}
                // Get {{ p.type }} min value by {{ x }}
                [Test]
                public static void GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min() {
                    var result = Global.GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

                    {{ assert_are_equal(p.use_epsilon, "result.Value", p.min) }}
                }

                // Get {{ p.type }} max value by {{ x }}
                [Test]
                public static void GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max() {
                    var result = Global.GlobalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

                    {{ assert_are_equal(p.use_epsilon, "result.Value", p.max) }}
                }
            {% endfor %}
        {% endfor %}


        // String

        {% for x in ['Value', 'ConstReference'] %}
            // Get string by {{ x }}
            [Test]
            public static void GlobalFunctions_String_Return{{ x }}() {
                var result = Global.GlobalFunctions_String_Return{{ x }}();

                Assert.AreEqual("{{ config.string_value }}", result);
            }
        {% endfor %}


        // Classes

        {% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
            // Get class by {{ x }}
            [Test]
            public static void GlobalFunctions_MyClass_Return{{ x }}() {
                using var result = Global.GlobalFunctions_MyClass_Return{{ x }}();

                Assert.IsTrue(result.PointerIsValid);
                Assert.AreEqual({{ config.class_int_value_first }}, result.SomeValue);
            }
        {% endfor %}


        // Parameter types

        // Primitives

        {% for p in config.primitives %}
            // Pass {{ p.type }} min value by value
            [Test]
            public static void GlobalFunctions_Primitives_{{ p.type }}_PassValue_min() {
                try {
                    Global.GlobalFunctions_Primitives_{{ p.type }}_PassValue_min({{ p.min }});
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }

            // Pass {{ p.type }} max value by value
            [Test]
            public static void GlobalFunctions_Primitives_{{ p.type }}_PassValue_max() {
                try {
                    Global.GlobalFunctions_Primitives_{{ p.type }}_PassValue_max({{ p.max }});
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }

            // Get {{ p.type }} min value via out parameter
            [Test]
            public static void GlobalFunctions_Primitives_{{ p.type }}_PassOut_min() {
                Global.GlobalFunctions_Primitives_{{ p.type }}_PassOut_min(out var result);

                {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
            }

            // Get {{ p.type }} max value via out parameter
            [Test]
            public static void GlobalFunctions_Primitives_{{ p.type }}_PassOut_max() {
                Global.GlobalFunctions_Primitives_{{ p.type }}_PassOut_max(out var result);

                {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
            }

            // Pass {{ p.type }} min value and get max value via in-out parameter
            [Test]
            public static void GlobalFunctions_Primitives_{{ p.type }}_PassInOut_minmax() {
                var value = {{ p.min }};

                try {
                    Global.GlobalFunctions_Primitives_{{ p.type }}_PassInOut_minmax(ref value);
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }

                {{ assert_are_equal(p.use_epsilon, "value", p.max) }}
            }
        {% endfor %}


        // String
        {% for x in ['Value', 'ConstReference'] %}
            // Pass string by {{ x }}
            [Test]
            public static void GlobalFunctions_String_Pass{{ x }}() {
                try {
                    Global.GlobalFunctions_String_Pass{{ x }}("{{ config.string_value }}");
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }
        {% endfor %}


        // Classes
        {% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
            // Pass class by {{ x }}
            [Test]
            public static void GlobalFunctions_MyClass_Pass{{ x }}() {
                using var param = new MyClass({{ config.class_int_value_first }});

                try {
                    Global.GlobalFunctions_MyClass_Pass{{ x }}(param);
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }
        {% endfor %}


        /********************************/
        /*           Classes            */
        /********************************/

        /// Constructors

        static List<ConstructorInfo> GetAllConstructors(this Type type) {
            var flags = BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance;
            var ctors = type.GetConstructors(flags).ToList();

            // Remove internal NativePointer constructor
            ctors.Remove(
                ctors.Find(
                    c =>
                        c.GetParameters().Length == 1
                        && c.GetParameters()[0].ParameterType.Name == "NativePointer"
                )
            );

            return ctors;
        }

        [Test]
        public static void Check_DefaultConstructorClass_Constructors() {
            var ctors = typeof(DefaultConstructorClass).GetAllConstructors();

            Assert.AreEqual(1, ctors.Count);

            var ctor = ctors[0];

            Assert.IsFalse(ctor.IsStatic);
            Assert.IsFalse(ctor.IsVirtual);

            var @params = ctor.GetParameters();

            Assert.AreEqual(0, @params.Length);
        }

        [Test]
        public static void Create_DefaultConstructorClass() {
            using var instance = new DefaultConstructorClass();

            Assert.IsTrue(instance.PointerIsValid);
            Assert.AreEqual({{ config.class_int_value_first }}, instance.SomeValue);
        }

        [Test]
        public static void Check_ParameterConstructorClass_Constructors() {
            var ctors = typeof(ParameterConstructorClass).GetAllConstructors();

            Assert.AreEqual(1, ctors.Count);

            var ctor = ctors[0];

            Assert.IsFalse(ctor.IsStatic);
            Assert.IsFalse(ctor.IsVirtual);

            var @params = ctor.GetParameters();

            Assert.AreEqual(1, @params.Length);
            Assert.AreEqual(typeof(int), @params[0].ParameterType);
        }

        [Test]
        public static void Create_ParameterConstructorClass() {
            using var instance = new ParameterConstructorClass({{ config.class_int_value_first }});

            Assert.IsTrue(instance.PointerIsValid);
            Assert.AreEqual({{ config.class_int_value_first }}, instance.SomeValue);
        }

        [Test]
        public static void Check_ParametersConstructorClass_Constructors() {
            var ctors = typeof(ParametersConstructorClass).GetAllConstructors();

            Assert.AreEqual(ctors.Count, 1);

            var ctor = ctors[0];

            Assert.IsFalse(ctor.IsStatic);
            Assert.IsFalse(ctor.IsVirtual);

            var @params = ctor.GetParameters();

            Assert.AreEqual(2, @params.Length);
            Assert.AreEqual(typeof(int), @params[0].ParameterType);
            Assert.AreEqual(typeof(bool), @params[1].ParameterType);
        }

        [Test]
        public static void Create_ParametersConstructorClass() {
            using var instance = new ParametersConstructorClass({{ config.class_int_value_first }}, true);

            Assert.IsTrue(instance.PointerIsValid);
            Assert.AreEqual({{ config.class_int_value_first }}, instance.SomeValue);
            Assert.AreEqual(true, instance.AnotherValue);
        }

        [Test]
        public static void Check_MultipleConstructorsClass_Constructors() {
            var ctors = typeof(MultipleConstructorsClass).GetAllConstructors();

            Assert.AreEqual(2, ctors.Count);

            bool found1 = false, found2 = false;

            foreach (var ctor in ctors) {
                Assert.IsFalse(ctor.IsStatic);
                Assert.IsFalse(ctor.IsVirtual);

                var @params = ctor.GetParameters();

                if (@params.Length == 0) {
                    found1 = true;
                }
                else if (@params.Length == 1) {
                    Assert.AreEqual(typeof(int), @params[0].ParameterType);

                    found2 = true;
                }
                else {
                    Assert.Fail("Unexpected constructor found!");
                }
            }

            Assert.IsTrue(found1 && found2);
        }

        [Test]
        public static void Create_MultipleConstructorsClass() {
            // Default
            {
                using var instance = new MultipleConstructorsClass();

                Assert.IsTrue(instance.PointerIsValid);
                Assert.AreEqual({{ config.class_int_value_first }}, instance.SomeValue);
            }

            // Single parameter
            {
                using var instance = new MultipleConstructorsClass({{ config.class_int_value_second }});

                Assert.IsTrue(instance.PointerIsValid);
                Assert.AreEqual({{ config.class_int_value_second }}, instance.SomeValue);
            }
        }

        [Test]
        public static void Check_ProtectedConstructorClass_Constructors() {
            var ctors = typeof(ProtectedConstructorClass).GetAllConstructors();

            Assert.AreEqual(1, ctors.Count);
            
            var ctor = ctors[0];

            Assert.IsTrue(ctor.IsFamily);
            
            var @params = ctor.GetParameters();

            Assert.AreEqual(0, @params.Length);
        }

        [Test]
        public static void Check_PrivateConstructorClass_Constructors() {
            var ctors = typeof(PrivateConstructorClass).GetAllConstructors();

            Assert.AreEqual(1, ctors.Count);
            
            var ctor = ctors[0];

            Assert.IsTrue(ctor.IsFamily);
            
            var @params = ctor.GetParameters();

            Assert.AreEqual(0, @params.Length);
        }

        [Test]
        public static void Check_DeletedConstructorClass_Constructors() {
            var ctors = typeof(DeletedConstructorClass).GetAllConstructors();

            Assert.AreEqual(1, ctors.Count);
            
            var ctor = ctors[0];

            Assert.IsTrue(ctor.IsFamily);
            
            var @params = ctor.GetParameters();

            Assert.AreEqual(0, @params.Length);
        }


        // Destructors

        [Test]
        public static void Check_PublicDestructorClass_Destructor() {
            Assert.IsTrue(typeof(IDisposable).IsAssignableFrom(typeof(PublicDestructorClass)));
        }

        [Test]
        public static void Check_ProtectedDestructorClass_Destructor() {
            Assert.IsFalse(typeof(IDisposable).IsAssignableFrom(typeof(ProtectedDestructorClass)));
        }

        [Test]
        public static void Check_PrivateDestructorClass_Destructor() {
            Assert.IsFalse(typeof(IDisposable).IsAssignableFrom(typeof(PrivateDestructorClass)));
        }

        [Test]
        public static void Check_DeletedDestructorClass_Destructor() {
            Assert.IsFalse(typeof(IDisposable).IsAssignableFrom(typeof(DeletedDestructorClass)));
        }


        /// Fields

        // Primitives

        [Test]
        public static void Check_PrimitiveFieldTestClass_Fields() {
            using var instance = new PrimitiveFieldTestClass {
                {% for p in config.primitives %}
                    Field{{ loop.index0 }} = {{ p.min }}{{ ',' if not loop.last }}
                {% endfor %}
            };

            try {
                Global.Check_PrimitiveFieldTestClass_Fields(instance);
            }
            catch (RuntimeWrappedException e) {
                Assert.Fail(e.Message);
            }
        }

        [Test]
        public static void Set_PrimitiveFieldTestClass_Fields() {
            using var instance = new PrimitiveFieldTestClass();
            Global.Set_PrimitiveFieldTestClass_Fields(instance);

            {% for p in config.primitives %}
                {% set field_name %}
                    instance.Field{{ loop.index0 }}
                {% endset %}

                {{ assert_are_equal(p.use_epsilon, field_name, p.max) }}
            {% endfor %}
        }


        // String
        
        [Test]
        public static void Check_StringFieldTestClass_Field() {
            using var instance = new StringFieldTestClass {
                Field = "{{ config.class_string_value_first }}"
            };

            try {
                Global.Check_StringFieldTestClass_Field(instance);
            }
            catch (RuntimeWrappedException e) {
                Assert.Fail(e.Message);
            }
        }

        [Test]
        public static void Set_StringFieldTestClass_Field() {
            using var instance = new StringFieldTestClass();
            Global.Set_StringFieldTestClass_Field(instance);

            Assert.AreEqual("{{ config.class_string_value_second }}", instance.Field);
        }


        // Classes

        [Test]
        public static void Check_ClassFieldTestClass_Field() {
            using var instance = new ClassFieldTestClass();
            instance.Field.ACoolInteger = {{ config.class_int_value_first }};

            try {
                Global.Check_ClassFieldTestClass_Field(instance);
            }
            catch (RuntimeWrappedException e) {
                Assert.Fail(e.Message);
            }
        }

        [Test]
        public static void Set_ClassFieldTestClass_Field() {
            using var instance = new ClassFieldTestClass();
            Global.Set_ClassFieldTestClass_Field(instance);

            Assert.AreEqual({{ config.class_int_value_second }}, instance.Field.ACoolInteger);
        }


        /// Functions

        // Return types

        // Primitives

        {% for p in config.primitives %}
            {% for x in ['Value', 'ConstPointer', 'ConstReference'] %}
                [Test]
                public static void ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_min() {
                    using var instance = new PrimitiveReturnTestClass();
                    var result = instance.ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

                    {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
                }

                [Test]
                public static void ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_max() {
                    using var instance = new PrimitiveReturnTestClass();
                    var result = instance.ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

                    {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
                }
            {% endfor %}

            {% for x in ['Pointer', 'Reference'] %}
                [Test]
                public static void ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_min() {
                    using var instance = new PrimitiveReturnTestClass();
                    var result = instance.ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

                    {{ assert_are_equal(p.use_epsilon, "result.Value", p.min) }}
                }

                [Test]
                public static void ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_max() {
                    using var instance = new PrimitiveReturnTestClass();
                    var result = instance.ClassFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

                    {{ assert_are_equal(p.use_epsilon, "result.Value", p.max) }}
                }
            {% endfor %}
        {% endfor %}


        // String

        {% for x in ['Value', 'ConstReference'] %}
            // Get string by {{ x }}
            [Test]
            public static void ClassFunctions_String_Return{{ x }}() {
                using var instance = new StringReturnTestClass();
                var result = instance.ClassFunctions_String_Return{{ x }}();

                Assert.AreEqual("{{ config.string_value }}", result);
            }
        {% endfor %}


        // Classes

        {% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
            // Get class by {{ x }}
            [Test]
            public static void ClassFunctions_MyClass_Return{{ x }}() {
                using var instance = new ClassReturnTestClass();
                using var result = instance.ClassFunctions_MyClass_Return{{ x }}();

                Assert.IsTrue(result.PointerIsValid);
                Assert.AreEqual({{ config.class_int_value_first }}, result.SomeValue);
            }
        {% endfor %}


        // Parameter types

        // Primitives

        {% for p in config.primitives %}
            // Pass {{ p.type }} min value by value
            [Test]
            public static void ClassFunctions_Primitives_{{ p.type }}_PassValue_min() {
                using var instance = new PrimitiveParameterTestClass();

                try {
                    instance.ClassFunctions_Primitives_{{ p.type }}_PassValue_min({{ p.min }});
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }

            // Pass {{ p.type }} max value by value
            [Test]
            public static void ClassFunctions_Primitives_{{ p.type }}_PassValue_max() {
                using var instance = new PrimitiveParameterTestClass();

                try {
                    instance.ClassFunctions_Primitives_{{ p.type }}_PassValue_max({{ p.max }});
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }

            {# TODO: Add support for out and in-out params in class methods #}
            {# // Get {{ p.type }} min value via out parameter
            [Test]
            public static void ClassFunctions_Primitives_{{ p.type }}_PassOut_min() {
                Global.ClassFunctions_Primitives_{{ p.type }}_PassOut_min(out var result);

                {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
            }

            // Get {{ p.type }} max value via out parameter
            [Test]
            public static void ClassFunctions_Primitives_{{ p.type }}_PassOut_max() {
                Global.ClassFunctions_Primitives_{{ p.type }}_PassOut_max(out var result);

                {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
            }

            // Pass {{ p.type }} min value and get max value via in-out parameter
            [Test]
            public static void ClassFunctions_Primitives_{{ p.type }}_PassInOut_minmax() {
                var value = {{ p.min }};

                try {
                    Global.ClassFunctions_Primitives_{{ p.type }}_PassInOut_minmax(ref value);
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }

                {{ assert_are_equal(p.use_epsilon, "value", p.max) }}
            } #}
        {% endfor %}


        // String
        {% for x in ['Value', 'ConstReference'] %}
            // Pass string by {{ x }}
            [Test]
            public static void ClassFunctions_String_Pass{{ x }}() {
                using var instance = new StringParameterTestClass();

                try {
                    instance.ClassFunctions_String_Pass{{ x }}("{{ config.string_value }}");
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }
        {% endfor %}


        // Classes
        {% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
            // Pass class by {{ x }}
            [Test]
            public static void ClassFunctions_MyClass_Pass{{ x }}() {
                using var instance = new ClassParameterTestClass();
                using var param = new MyClass({{ config.class_int_value_first }});

                try {
                    instance.ClassFunctions_MyClass_Pass{{ x }}(param);
                }
                catch (RuntimeWrappedException e) {
                    Assert.Fail(e.Message);
                }
            }
        {% endfor %}
    }
}