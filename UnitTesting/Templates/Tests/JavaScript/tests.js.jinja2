{% from 'helpers.jinja2' import assert_are_equal %}

import { test, assert } from './test_framework.js';
import * as dummy from '@magnopus/com.magnopus.olympus.foundation.dummy';


/********************************/
/*       Global functions       */
/********************************/

/// Return types

// Primitives

{% for p in config.primitives %}
    {# The code in these tests is nearly identical, so just loop to avoid code duplication #}
    {% for x in ['Value', 'ConstPointer', 'ConstReference'] %}
        // Get {{ p.type }} min value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

            {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
        });

        // Get {{ p.type }} max value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

            {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
        });
    {% endfor %}

    {# Primitive non-const pointers and non-const references are returned as NativeRef instances, so pass #}
    {# 'result.value' instead of 'result'                                                                 #}
    {% for x in ['Pointer', 'Reference'] %}
        // Get {{ p.type }} min value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

            {{ assert_are_equal(p.use_epsilon, "result.value", p.min) }}
        });

        // Get {{ p.type }} max value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

            {{ assert_are_equal(p.use_epsilon, "result.value", p.max) }}
        });
    {% endfor %}
{% endfor %}


// String

{% for x in ['Value', 'ConstReference'] %}
    // Get string by {{ x }}
    test('globalFunctions_String_Return{{ x }}', async function() {
        const result = dummy.globalFunctions_String_Return{{ x }}();

        assert.areEqual(result, "{{ config.string_value }}");
    });
{% endfor %}


// Classes

{# All class return types are returned from the C wrapper by pointer, regardless of the C++ return type #}
{% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
    // Get class by {{ x }}
    test('globalFunctions_MyClass_Return{{ x }}', async function() {
        const result = dummy.globalFunctions_MyClass_Return{{ x }}();

        assert.isTrue(result.pointerIsValid());
        assert.areEqual(result.someValue, {{ config.class_int_value_first }});

        result.delete();
    });
{% endfor %}


/// Parameters

// Primitives

{% for p in config.primitives %}
    // Pass {{ p.type }} min value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassValue_min', async function() {
        try {
            dummy.globalFunctions_Primitives_{{ p.type }}_PassValue_min({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }
    });

    // Pass {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassValue_max', async function() {
        try {
            dummy.globalFunctions_Primitives_{{ p.type }}_PassValue_max({{ p.max }});
        }
        catch (e) {
            assert.fail(e.message);
        }
    });

    {# Out and in-out parameters are transformed into return parameters for the TypeScript wrapper, as TypeScript    #}
    {# doesn't support out or ref parameters like C# does. Functions with no return value and a single out or in-out #}
    {# parameter will return a single value. Functions with multiple out or in-out parameters or an out or in-out    #}
    {# parameter and a return value will return an anonymous object containing all values. Return values in this     #}
    {# object will be returned as 'result'. Out or in-out results will be returned as their C parameter name, minus  #}
    {# the "Out" or "InOut" at the start of the name.                                                                #}
    // Get {{ p.type }} min value via out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min();

        {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
    });

    // Get {{ p.type }} max value via out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_max', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_max();

        {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
    });

    // Get {{ p.type }} min and max value via out parameters
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_minmax', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_minmax();

        {{ assert_are_equal(p.use_epsilon, "result.minValue", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.maxValue", p.max) }}
    });

    // Get {{ p.type }} min value via out parameter and return {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min_ReturnValue_max', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min_ReturnValue_max();

        {{ assert_are_equal(p.use_epsilon, "result.result", p.max) }}
        {{ assert_are_equal(p.use_epsilon, "result.value", p.min) }}
    });

    // Get {{ p.type }} min and max value via out parameters and return {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_minmax_ReturnValue_min', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_minmax_ReturnValue_min();

        {{ assert_are_equal(p.use_epsilon, "result.result", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.minValue", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.maxValue", p.max) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter, and pass {{ p.type }} max value and
    // get min value via another in-out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin(
                {{ p.min }},
                {{ p.max }}
            );
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.value1", p.max) }}
        {{ assert_are_equal(p.use_epsilon, "result.value2", p.min) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter, and get {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_ReturnValue_max', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_ReturnValue_max({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.result", p.max) }}
        {{ assert_are_equal(p.use_epsilon, "result.value", p.max) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter, pass {{ p.type }} max value and get min
    // value via another in-out parameter, and get {{ p.type }} min value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin_ReturnValue_min',
        async function() {
            let result;

            try {
                result =
                    dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin_ReturnValue_min(
                        {{ p.min }},
                        {{ p.max }}
                    );
            }
            catch (e) {
                assert.fail(e.message);
            }

            {{ assert_are_equal(p.use_epsilon, "result.result", p.min) }}
            {{ assert_are_equal(p.use_epsilon, "result.value1", p.max) }}
            {{ assert_are_equal(p.use_epsilon, "result.value2", p.min) }}
        }
    );

    // Get {{ p.type }} min value via out parameter, and pass {{ p.type }} min value and get max value via in-out
    // parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.value1", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.value2", p.max) }}
    });

    // Get {{ p.type }} min value via out parameter, pass {{ p.type }} min value and get max value via in-out
    // parameter, and get {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax_ReturnValue_max', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax_ReturnValue_max(
                {{ p.min }}
            );
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.value1", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.value2", p.max) }}
    });
{% endfor %}


// String

{% for x in ['Value', 'ConstReference'] %}
    // Pass string by {{ x }}
    test('globalFunctions_String_Pass{{ x }}', async function() {
        try {
            dummy.globalFunctions_String_Pass{{ x }}("{{ config.string_value }}");
        }
        catch (e) {
            assert.fail(e.message)
        }
    });
{% endfor %}


// Classes

{% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
    // Pass class by {{ x }}
    test('globalFunctions_MyClass_Pass{{ x }}', async function() {
        var instance = dummy.MyClass.create_value({{ config.class_int_value_first }});

        try {
            dummy.globalFunctions_MyClass_Pass{{ x }}(instance);
        }
        catch (e) {
            assert.fail(e.message)
        }
    });
{% endfor %}


/********************************/
/*           Classes            */
/********************************/

/// Fields

// Primitives

test('check_PrimitiveFieldTestClass_Fields', async function() {
    const instance = dummy.PrimitiveFieldTestClass.create();

    {% for p in config.primitives %}
        instance.field{{ loop.index0 }} = {{ p.min }};
    {% endfor %}

    try {
        dummy.check_PrimitiveFieldTestClass_Fields(instance);
    }
    catch (e) {
        assert.fail(e.message);
    }
});

test('set_PrimitiveFieldTestClass_Fields', async function() {
    const instance = dummy.PrimitiveFieldTestClass.create();
    dummy.set_PrimitiveFieldTestClass_Fields(instance);

    {% for p in config.primitives %}
        {% set field_name %}
            instance.field{{ loop.index0 }}
        {% endset %}

        {{ assert_are_equal(p.use_epsilon, field_name, p.max) }}
    {% endfor %}
});


// String

test('check_StringFieldTestClass_Field', async function() {
    const instance = dummy.StringFieldTestClass.create();
    instance.field = "{{ config.class_string_value_first }}";

    try {
        dummy.check_StringFieldTestClass_Field(instance);
    }
    catch (e) {
        assert.fail(e.message);
    }
});

test('set_StringFieldTestClass_Field', async function() {
    const instance = dummy.StringFieldTestClass.create();
    dummy.set_StringFieldTestClass_Field(instance);

    assert.areEqual(instance.field, "{{ config.class_string_value_second }}");
});


// Class

test('check_ClassFieldTestClass_Field', async function() {
    const instance = dummy.ClassFieldTestClass.create();
    instance.field.aCoolInteger = {{ config.class_int_value_first }};

    try {
        dummy.check_ClassFieldTestClass_Field(instance);
    }
    catch (e) {
        assert.fail(e.message);
    }
});

test('set_ClassFieldTestClass_Field', async function() {
    const instance = dummy.ClassFieldTestClass.create();
    dummy.set_ClassFieldTestClass_Field(instance);

    assert.areEqual(instance.field.aCoolInteger, {{ config.class_int_value_second }});
});