{% from 'helpers.jinja2' import assert_are_equal %}

import { test, assert } from './test_framework.js';
import * as dummy from '@magnopus/com.magnopus.olympus.foundation.dummy';


/********************************/
/*       Global functions       */
/********************************/

/// Return types

// Primitives

{% for p in config.primitives %}
    {# The code in these tests is nearly identical, so just loop to avoid code duplication #}
    {% for x in ['Value', 'ConstPointer', 'ConstReference'] %}
        // Get {{ p.type }} min value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

            {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
        });

        // Get {{ p.type }} max value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

            {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
        });
    {% endfor %}

    {# Primitive non-const pointers and non-const references are returned as NativeRef instances, so pass #}
    {# 'result.value' instead of 'result'                                                                 #}
    {% for x in ['Pointer', 'Reference'] %}
        // Get {{ p.type }} min value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_min();

            {{ assert_are_equal(p.use_epsilon, "result.value", p.min) }}
        });

        // Get {{ p.type }} max value by {{ x }}
        test('globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max', async function() {
            const result = dummy.globalFunctions_Primitives_{{ p.type }}_Return{{ x }}_max();

            {{ assert_are_equal(p.use_epsilon, "result.value", p.max) }}
        });
    {% endfor %}
{% endfor %}


// String

{% for x in ['Value', 'ConstReference'] %}
    // Get string by {{ x }}
    test('globalFunctions_String_Return{{ x }}', async function() {
        const result = dummy.globalFunctions_String_Return{{ x }}();

        assert.areEqual(result, "{{ config.string_value }}");
    });
{% endfor %}


// Classes

{# All class return types are returned from the C wrapper by pointer, regardless of the C++ return type #}
{% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
    // Get class by {{ x }}
    test('globalFunctions_MyClass_Return{{ x }}', async function() {
        const result = dummy.globalFunctions_MyClass_Return{{ x }}();

        assert.isTrue(result.pointerIsValid());
        assert.areEqual(result.someValue, {{ config.class_int_value_first }});

        result.delete();
    });
{% endfor %}


/// Parameters

// Primitives

{% for p in config.primitives %}
    // Pass {{ p.type }} min value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassValue_min', async function() {
        try {
            dummy.globalFunctions_Primitives_{{ p.type }}_PassValue_min({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }
    });

    // Pass {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassValue_max', async function() {
        try {
            dummy.globalFunctions_Primitives_{{ p.type }}_PassValue_max({{ p.max }});
        }
        catch (e) {
            assert.fail(e.message);
        }
    });

    {# Out and in-out parameters are transformed into return parameters for the TypeScript wrapper, as TypeScript    #}
    {# doesn't support out or ref parameters like C# does. Functions with no return value and a single out or in-out #}
    {# parameter will return a single value. Functions with multiple out or in-out parameters or an out or in-out    #}
    {# parameter and a return value will return an anonymous object containing all values. Return values in this     #}
    {# object will be returned as 'result'. Out or in-out results will be returned as their C parameter name, minus  #}
    {# the "Out" or "InOut" at the start of the name.                                                                #}
    // Get {{ p.type }} min value via out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min();

        {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
    });

    // Get {{ p.type }} max value via out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_max', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_max();

        {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
    });

    // Get {{ p.type }} min and max value via out parameters
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_minmax', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_minmax();

        {{ assert_are_equal(p.use_epsilon, "result.minValue", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.maxValue", p.max) }}
    });

    // Get {{ p.type }} min value via out parameter and return {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min_ReturnValue_max', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min_ReturnValue_max();

        {{ assert_are_equal(p.use_epsilon, "result.result", p.max) }}
        {{ assert_are_equal(p.use_epsilon, "result.value", p.min) }}
    });

    // Get {{ p.type }} min and max value via out parameters and return {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_minmax_ReturnValue_min', async function() {
        const result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_minmax_ReturnValue_min();

        {{ assert_are_equal(p.use_epsilon, "result.result", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.minValue", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.maxValue", p.max) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter, and pass {{ p.type }} max value and
    // get min value via another in-out parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin(
                {{ p.min }},
                {{ p.max }}
            );
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.value1", p.max) }}
        {{ assert_are_equal(p.use_epsilon, "result.value2", p.min) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter, and get {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_ReturnValue_max', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_ReturnValue_max({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.result", p.max) }}
        {{ assert_are_equal(p.use_epsilon, "result.value", p.max) }}
    });

    // Pass {{ p.type }} min value and get max value via in-out parameter, pass {{ p.type }} max value and get min
    // value via another in-out parameter, and get {{ p.type }} min value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin_ReturnValue_min',
        async function() {
            let result;

            try {
                result =
                    dummy.globalFunctions_Primitives_{{ p.type }}_PassInOut_minmax_PassInOut_maxmin_ReturnValue_min(
                        {{ p.min }},
                        {{ p.max }}
                    );
            }
            catch (e) {
                assert.fail(e.message);
            }

            {{ assert_are_equal(p.use_epsilon, "result.result", p.min) }}
            {{ assert_are_equal(p.use_epsilon, "result.value1", p.max) }}
            {{ assert_are_equal(p.use_epsilon, "result.value2", p.min) }}
        }
    );

    // Get {{ p.type }} min value via out parameter, and pass {{ p.type }} min value and get max value via in-out
    // parameter
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax({{ p.min }});
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.value1", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.value2", p.max) }}
    });

    // Get {{ p.type }} min value via out parameter, pass {{ p.type }} min value and get max value via in-out
    // parameter, and get {{ p.type }} max value by value
    test('globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax_ReturnValue_max', async function() {
        let result;

        try {
            result = dummy.globalFunctions_Primitives_{{ p.type }}_PassOut_min_PassInOut_minmax_ReturnValue_max(
                {{ p.min }}
            );
        }
        catch (e) {
            assert.fail(e.message);
        }

        {{ assert_are_equal(p.use_epsilon, "result.value1", p.min) }}
        {{ assert_are_equal(p.use_epsilon, "result.value2", p.max) }}
    });
{% endfor %}


// String

{% for x in ['Value', 'ConstReference'] %}
    // Pass string by {{ x }}
    test('globalFunctions_String_Pass{{ x }}', async function() {
        try {
            dummy.globalFunctions_String_Pass{{ x }}("{{ config.string_value }}");
        }
        catch (e) {
            assert.fail(e.message)
        }
    });
{% endfor %}


// Classes

{% for x in ['Value', 'Pointer', 'ConstPointer', 'Reference', 'ConstReference'] %}
    // Pass class by {{ x }}
    test('globalFunctions_MyClass_Pass{{ x }}', async function() {
        var instance = dummy.MyClass.create_value({{ config.class_int_value_first }});

        try {
            dummy.globalFunctions_MyClass_Pass{{ x }}(instance);
        }
        catch (e) {
            assert.fail(e.message)
        }
    });
{% endfor %}


/********************************/
/*           Classes            */
/********************************/

/// Constructors

function getAllConstructors(prototype) {
    const props = Object.getOwnPropertyNames(prototype);
    const ctors = props.filter(x => typeof prototype[x] === 'function' && x.startsWith('create'));

    return ctors;
}

test('check_DefaultConstructorClass_Constructors', async function() {
    // Static functions are defined directly on the object. Instance functions are defined on the prototype.
    const ctorNames = getAllConstructors(dummy.DefaultConstructorClass);

    assert.areEqual(ctorNames.length, 1);

    const ctor = dummy.DefaultConstructorClass[ctorNames[0]];

    // Function.length returns the number of parameters expected
    assert.areEqual(ctor.length, 0);
});

test('create_DefaultConstructorClass', async function() {
    const instance = dummy.DefaultConstructorClass.create();

    assert.isTrue(instance.pointerIsValid());
    assert.areEqual(instance.someValue, {{ config.class_int_value_first }});
});

test('check_ParameterConstructorClass_Constructors', async function() {
    const ctorNames = getAllConstructors(dummy.ParameterConstructorClass);

    assert.areEqual(ctorNames.length, 1);

    const ctor = dummy.ParameterConstructorClass[ctorNames[0]];

    assert.areEqual(ctor.length, 1);
});

test('create_ParameterConstructorClass', async function() {
    const instance = dummy.ParameterConstructorClass.create_someParameter({{ config.class_int_value_first }});

    assert.isTrue(instance.pointerIsValid());
    assert.areEqual(instance.someValue, {{ config.class_int_value_first }});
});

test('check_ParametersConstructorClass_Constructors', async function() {
    const ctorNames = getAllConstructors(dummy.ParametersConstructorClass);

    assert.areEqual(ctorNames.length, 1);

    const ctor = dummy.ParametersConstructorClass[ctorNames[0]];

    assert.areEqual(ctor.length, 2);
});

test('create_ParametersConstructorClass', async function() {
    const instance = dummy.ParametersConstructorClass.create_someParameter_anotherParameter(
        {{ config.class_int_value_first }},
        true
    );

    assert.isTrue(instance.pointerIsValid());
    assert.areEqual(instance.someValue, {{ config.class_int_value_first }});
});

test('check_MultipleConstructorsClass_Constructors', async function() {
    const ctorNames = getAllConstructors(dummy.MultipleConstructorsClass);

    assert.areEqual(ctorNames.length, 2);
    assert.isTrue(ctorNames.includes('create') && dummy.MultipleConstructorsClass['create'].length == 0);
    assert.isTrue(ctorNames.includes('create_someParameter') 
        && dummy.MultipleConstructorsClass['create_someParameter'].length == 1);
});

test('create_MultipleConstructorsClass', async function() {
    let instance = dummy.MultipleConstructorsClass.create();

    assert.isTrue(instance.pointerIsValid());
    assert.areEqual(instance.someValue, {{ config.class_int_value_first }});

    instance = dummy.MultipleConstructorsClass.create_someParameter({{ config.class_int_value_second }});

    assert.isTrue(instance.pointerIsValid());
    assert.areEqual(instance.someValue, {{ config.class_int_value_second }});
});

test('check_ProtectedConstructorClass_Constructors', async function() {
    const ctorNames = getAllConstructors(dummy.ProtectedConstructorClass);

    assert.areEqual(ctorNames.length, 0);
});

test('check_PrivateConstructorClass_Constructors', async function() {
    const ctorNames = getAllConstructors(dummy.PrivateConstructorClass);

    assert.areEqual(ctorNames.length, 0);
});

test('check_DeletedConstructorClass_Constructors', async function() {
    const ctorNames = getAllConstructors(dummy.DeletedConstructorClass);

    assert.areEqual(ctorNames.length, 0);
});


// Destructors

test('check_PublicDestructorClass_Destructor', async function() {
    assert.areEqual(typeof dummy.PublicDestructorClass.prototype['delete'], 'function');
});

test('check_ProtectedDestructorClass_Destructor', async function() {
    assert.areEqual(typeof dummy.ProtectedDestructorClass.prototype['delete'], 'undefined');
});

test('check_PrivateDestructorClass_Destructor', async function() {
    assert.areEqual(typeof dummy.PrivateDestructorClass.prototype['delete'], 'undefined');
});

test('check_DeletedDestructorClass_Destructor', async function() {
    assert.areEqual(typeof dummy.DeletedDestructorClass.prototype['delete'], 'undefined');
});


/// Fields

// Primitives

test('check_PrimitiveFieldTestClass_Fields', async function() {
    const instance = dummy.PrimitiveFieldTestClass.create();

    {% for p in config.primitives %}
        instance.field{{ loop.index0 }} = {{ p.min }};
    {% endfor %}

    try {
        dummy.check_PrimitiveFieldTestClass_Fields(instance);
    }
    catch (e) {
        assert.fail(e.message);
    }
});

test('set_PrimitiveFieldTestClass_Fields', async function() {
    const instance = dummy.PrimitiveFieldTestClass.create();
    dummy.set_PrimitiveFieldTestClass_Fields(instance);

    {% for p in config.primitives %}
        {% set field_name %}
            instance.field{{ loop.index0 }}
        {% endset %}

        {{ assert_are_equal(p.use_epsilon, field_name, p.max) }}
    {% endfor %}
});


// String

test('check_StringFieldTestClass_Field', async function() {
    const instance = dummy.StringFieldTestClass.create();
    instance.field = "{{ config.class_string_value_first }}";

    try {
        dummy.check_StringFieldTestClass_Field(instance);
    }
    catch (e) {
        assert.fail(e.message);
    }
});

test('set_StringFieldTestClass_Field', async function() {
    const instance = dummy.StringFieldTestClass.create();
    dummy.set_StringFieldTestClass_Field(instance);

    assert.areEqual(instance.field, "{{ config.class_string_value_second }}");
});


// Class

test('check_ClassFieldTestClass_Field', async function() {
    const instance = dummy.ClassFieldTestClass.create();
    instance.field.aCoolInteger = {{ config.class_int_value_first }};

    try {
        dummy.check_ClassFieldTestClass_Field(instance);
    }
    catch (e) {
        assert.fail(e.message);
    }
});

test('set_ClassFieldTestClass_Field', async function() {
    const instance = dummy.ClassFieldTestClass.create();
    dummy.set_ClassFieldTestClass_Field(instance);

    assert.areEqual(instance.field.aCoolInteger, {{ config.class_int_value_second }});
});


/// Functions

// Return types

// Primitives

{% for p in config.primitives %}
    {% for x in ['Value', 'ConstPointer', 'ConstReference'] %}
        test('classFunctions_Primitives_{{ p.type }}_Return{{ x }}_min', async function() {
            const instance = dummy.PrimitiveReturnTestClass.create();
            const result = instance.functions_Primitives_{{ p.type }}_Return{{ x }}_min();

            {{ assert_are_equal(p.use_epsilon, "result", p.min) }}
        });

        test('classFunctions_Primitives_{{ p.type }}_Return{{ x }}_max', async function() {
            const instance = dummy.PrimitiveReturnTestClass.create();
            const result = instance.functions_Primitives_{{ p.type }}_Return{{ x }}_max();

            {{ assert_are_equal(p.use_epsilon, "result", p.max) }}
        });
    {% endfor %}

    {% for x in ['Pointer', 'Reference'] %}
        test('classFunctions_Primitives_{{ p.type }}_Return{{ x }}_min', async function() {
            const instance = dummy.PrimitiveReturnTestClass.create();
            const result = instance.functions_Primitives_{{ p.type }}_Return{{ x }}_min();

            {{ assert_are_equal(p.use_epsilon, "result.value", p.min) }}
        });

        test('classFunctions_Primitives_{{ p.type }}_Return{{ x }}_max', async function() {
            const instance = dummy.PrimitiveReturnTestClass.create();
            const result = instance.functions_Primitives_{{ p.type }}_Return{{ x }}_max();

            {{ assert_are_equal(p.use_epsilon, "result.value", p.max) }}
        });
    {% endfor %}
{% endfor %}