#pragma once

#include "Olympus/Common/Array.h"
#include "Olympus/Common/Map.h"
#include "Olympus/Common/String.h"
#include "Olympus/Multiplayer/ComponentBase.h"
#include "Olympus/Multiplayer/IEntitySerialiser.h"
#include "Olympus/Multiplayer/SpaceTransform.h"
#include "Olympus/OlympusCommon.h"
#include "Olympus/ThirdPartyPlatforms.h"
#include "SpaceEntitySystem.h"

#include <atomic>
#include <functional>
#include <mutex>

OLY_START_IGNORE
#ifdef OLY_TESTS
class OlympusEngine_SerialisationTests_SpaceEntityUserSignalRSerialisationTest_Test;
class OlympusEngine_SerialisationTests_SpaceEntityUserSignalRSerialisationTest_Test;
class OlympusEngine_SerialisationTests_SpaceEntityObjectSignalRDeserialisationTest_Test;
class OlympusEngine_SerialisationTests_SpaceEntityObjectSignalRDeserialisationTest_Test;
#endif
OLY_END_IGNORE

namespace oly_multiplayer
{
class SpaceEntitySystem;
class EntityScript;
class EntityScriptInterface;

enum class SpaceEntityType
{
    Avatar = 1,
    Object,
};

enum class ComponentUpdateType
{
    Update,
    Add,
    Delete,
};

class OLY_API PropertyUpdateInfo
{
public:
    uint32_t PropertyId;
    ComponentUpdateType UpdateType;
};

class OLY_API ComponentUpdateInfo
{
public:
    uint16_t ComponentId;
    ComponentUpdateType UpdateType;
    // Removing until we need this as part of the per property replication implementation
    // oly_common::Array<PropertyUpdateInfo> PropertyInfo;
};

enum SpaceEntityUpdateFlags
{
    UPDATE_FLAGS_NAME = 1,
    UPDATE_FLAGS_POSITION = 2,
    UPDATE_FLAGS_ROTATION = 4,
    UPDATE_FLAGS_SCALE = 8,
    UPDATE_FLAGS_COMPONENTS = 16,
    UPDATE_FLAGS_SELECTION_ID = 32,
    UPDATE_FLAGS_THIRD_PARTY_REF = 64,
    UPDATE_FLAGS_THIRD_PARTY_PLATFORM = 128,
};

class OLY_API SpaceEntity
{
    OLY_START_IGNORE
    /** @cond DO_NOT_DOCUMENT */
    friend class SpaceEntitySystem;
    friend class EntityScript;
    friend class EntityScriptInterface;
    friend class EntitySystemScriptInterface;
    friend class ComponentBase;
    friend class ComponentScriptInterface;
#ifdef OLY_TESTS
    friend class ::OlympusEngine_SerialisationTests_SpaceEntityUserSignalRSerialisationTest_Test;
    friend class ::OlympusEngine_SerialisationTests_SpaceEntityUserSignalRDeserialisationTest_Test;
    friend class ::OlympusEngine_SerialisationTests_SpaceEntityObjectSignalRSerialisationTest_Test;
    friend class ::OlympusEngine_SerialisationTests_SpaceEntityObjectSignalRDeserialisationTest_Test;
#endif
    /** @endcond */
    OLY_END_IGNORE

public:
    typedef std::function<void(SpaceEntity*, SpaceEntityUpdateFlags, oly_common::Array<ComponentUpdateInfo>&)> UpdateCallback;
    typedef std::function<void(bool)> DestroyCallback;
    typedef std::function<void(bool)> CallbackHandler;

    SpaceEntity();
    SpaceEntity(SpaceEntitySystem* InEntitySystem);
    ~SpaceEntity();

    /**
     * @brief Get the ID of this SpaceEntity, this is generated by the endpoints and should be unique to each Entity.
     * @return the uint64_t ID of the SpaceEntity.
     */
    uint64_t GetId() const;
    /**
     * @brief Get the ClientID of the owner of the SpaceEntity.
     * This starts as the user that creates the Entity but can change if another user patches the Entity.
     * @return the uint64_t ClientID of the owner of the SpaceEntity.
     */
    uint64_t GetOwnerId() const;
    /**
     * @brief Get the name set for this SpaceEntity.
     * @return Name.
     */
    const oly_common::String& GetName() const;
    /**
     * @brief Set the name of the SpaceEntity.
     * @param Value The name to set.
     */
    void SetName(const oly_common::String& Value);
    /**
     * @brief Get the SpaceTransform of the SpaceEntity.
     * @return SpaceTransform.
     */
    const SpaceTransform& GetTransform() const;
    /**
     * @brief Get the position of the SpaceEntity, in world space.
     * @return Position.
     */
    const oly_common::Vector3& GetPosition() const;
    /**
     * @brief Set the position of the SpaceEntity, in world space.
     * @param Value The position to set.
     */
    void SetPosition(const oly_common::Vector3& Value);
    /**
     * @brief Get the rotation of the SpaceEntity.
     * @return Rotation.
     */
    const oly_common::Vector4& GetRotation() const;
    /**
     * @brief Set the rotation of the SpaceEntity.
     * @param Value The rotation to set.
     */
    void SetRotation(const oly_common::Vector4& Value);
    /**
     * @brief Get the scale of the SpaceEntity.
     * @return Scale.
     */
    const oly_common::Vector3& GetScale() const;
    /**
     * @brief Set the scale of the SpaceEntity.
     * @param Value The scale to set.
     */
    void SetScale(const oly_common::Vector3& Value);
    /**
     * @brief Get is the SpaceEntity marked as transient?
     * @return returns !IsPersistant.
     */
    bool GetIsTransient() const;
    /**
     * @brief Get the party reference of this entity
     * @return returns a string representing the party reference set for this entity.
     */
    const oly_common::String& GetThirdPartyRef() const;

    /**
     * @brief Set the third party reference for this entity
     * @param InThirdPartyRef The third party reference to set.
     */

    void SetThirdPartyRef(const oly_common::String& InThirdPartyRef);

    /**
     * @brief Get the third party platform type of this entity
     * @return returns a string representing third party platform type set for this entity.
     */
    const oly_systems::EThirdPartyPlatform GetThirdPartyPlatformType() const;

    /**
     * @brief Set third party platform type for this entity
     * @param InThirdPartyPlatformType The third party platform type to set.
     */
    void SetThirdPartyPlatformType(const oly_systems::EThirdPartyPlatform InThirdPartyPlatformType);

    /**
     * @brief Get the type of the Entity.
     * @return The SpaceEntityType enum value.
     */
    SpaceEntityType GetEntityType() const;
    /**
     * @brief Get MultiplayerConnection Object
     */
    SpaceEntitySystem* GetSpaceEntitySystem();
    /**
     * @brief Queues an update which will be executed on next Tick() or ProcessPendingEntityOperations(). Not a blocking or async function.
     */
    void QueueUpdate();

    /**
     * @brief Sends a patch message with a flag to destroy the entity.
     * Will remove the entity from endpoints and signal remote clients to delete the entity.
     * Note this will trigger local deletion of the SpaceEntity immediately, without considering if remotes were able to also delete.
     * If the endpoint fails to process this message, the client that called this function will be out of sync.
     * It is advised to handle this situation by dropping the client out of a space if the callback comes back as failed.
     * @param Callback The callback triggers when the patch message completes, either successfully or unsuccessfully.
     */
    OLY_ASYNC_RESULT void Destroy(CallbackHandler Callback);

    /**
     * @brief Set a callback to be executed when a patch message is received for this Entity. Only one callback can be set.
     * @param Callback Contains the SpaceEntity that updated,
     * a set of flags to tell which parts updated and an array of information to tell which components updated.
     */
    OLY_EVENT void SetUpdateCallback(UpdateCallback Callback);

    /**
     * @brief Set a callback to be executed when a patch message with a destroy flag is received for this Entity. Only one callback can be set.
     * @param Callback Contains a bool that is true if the Entity is being deleted.
     */
    OLY_EVENT void SetDestroyCallback(DestroyCallback Callback);

    /**
     * @brief Get the map of components on this SpaceEntity.
     * @return A map of components indexed with the component ID.
     */
    const oly_common::Map<uint16_t, ComponentBase*>* GetComponents() const;

    // TODO: This asserts if the component is not found, we should allow a client to check if the component exists, currently they can't.
    /**
     * @brief Get a component on this SpaceEntity by the specified key. Only call if the component exists or it will assert!
     * @param Key
     * @return the component if found.
     */
    ComponentBase* GetComponent(uint16_t Key);

    /**
     * @brief Add a component of the given type.
     * @param Type the type of component to add.
     * @return the newly created component.
     */
    ComponentBase* AddComponent(ComponentType Type);

    /**
     * @brief Remove a component of the given key.
     * Note that the component cannot currently truly be removed from the server data,
     * the best we can do is add a blank component in its place, which clients decide to ignore when retrieving data.
     * @param Key
     */
    void RemoveComponent(uint16_t Key);

    /**
     * @brief Serialise local changes into patch message format into the given serialiser. Does not send a patch.
     * @param Serialiser
     */
    void SerialisePatch(IEntitySerialiser& Serialiser) const;

    /**
     * @brief Serialise the entire SpaceEntity into object message format into the given serialiser. Does not send a message.
     * @param Serialiser
     */
    void Serialise(IEntitySerialiser& Serialiser);

    /**
     * @brief Serialises a given component into a consistent format for the given serialiser.
     * @param Serialiser
     * @param Component
     */
    void SerialiseComponent(IEntitySerialiser& Serialiser, ComponentBase* Component) const;

    /**
     * @brief Using the given deserialiser, populate the SpaceEntity with the data in the deserialiser.
     * @param Deserialiser
     */
    void Deserialise(IEntityDeserialiser& Deserialiser);

    // TODO: Add documentation comment
    oly_multiplayer::EntityScript* GetScript();

    /**
     * @brief Returns the selection state of the entity.
     * @return Selection state of the entity, Selected = True, Deselected = False.
     */
    [[nodiscard]] bool IsSelected() const;

    /**
     * @brief Retrieve the ClientID for the Selecting Client.
     * @return The client ID of the selecting client. Deselected Entity = 0.
     */
    [[nodiscard]] uint64_t GetSelectingClientID() const;

    /**
     * @brief Select the Entity. Only works if the Entity is currently Deselected.
     * @return True if selection occurred. False if not.
     */
    bool Select();

    /**
     * @brief Deselect the Entity.
     * Only works if:
     * - The Entity is currently Selected
     * - The Client attempting to Deselect has the same ClientID as the one who Selected it
     * @return True if deselection occurred. False if not.
     */
    bool Deselect();

private:
    class DirtyComponent
    {
    public:
        ComponentBase* Component;
        ComponentUpdateType UpdateType;
    };

    void DeserialiseFromPatch(IEntityDeserialiser& Deserialiser);
    void ApplyLocalPatch(bool InvokeUpdateCallback = true);
    uint16_t GenerateComponentId();
    ComponentBase* InstantiateComponent(uint16_t Id, ComponentType Type);
    void AddDirtyComponent(ComponentBase* DirtyComponent);

    void AddRef();
    void RemoveRef();
    std::atomic_int* GetRefCount();

    void OnPropertyChanged(ComponentBase* DirtyComponent, int32_t PropertyKey);
    oly_multiplayer::EntityScriptInterface* GetScriptInterface();

    void ClaimScriptOwnership();
    void MarkForUpdate();

    // Do NOT call directly, always call either Select() Deselect() or SpaceEntitySystem::InternalSetSelectionStateOfEntity()
    bool InternalSetSelectionStateOfEntity(const bool SelectedState, uint64_t ClientID);

    void DestroyComponent(uint16_t Key);

    ComponentBase* FindFirstComponentOfType(ComponentType Type, bool SearchDirtyComponents = false) const;

    SpaceEntitySystem* EntitySystem;

    SpaceEntityType Type;
    uint64_t Id;
    bool IsTransferable;
    bool IsPersistant;
    uint64_t OwnerId;
    oly_common::String Name;
    SpaceTransform Transform;
    oly_systems::EThirdPartyPlatform ThirdPartyPlatform;
    oly_common::String ThirdPartyRef;
    uint64_t SelectedId;

    UpdateCallback EntityUpdateCallback;
    DestroyCallback EntityDestroyCallback;

    oly_common::Map<uint16_t, ComponentBase*> Components;
    oly_common::Map<uint16_t, ReplicatedValue> DirtyProperties;
    oly_common::Map<uint16_t, DirtyComponent> DirtyComponents;
    uint16_t NextComponentId;

    oly_multiplayer::EntityScript* Script;
    oly_multiplayer::EntityScriptInterface* ScriptInterface;

    std::mutex* EntityLock;
    std::mutex* ComponentsLock;
    std::mutex* PropertiesLock;

    std::atomic_int* RefCount;

    oly_common::List<uint16_t> TransientDeletionComponentIds;
};

} // namespace oly_multiplayer
