// WARNING: DO NOT EDIT THIS FILE! IT IS A GENERATED FILE AND
//   ANY CHANGES YOU MAKE WILL BE OVERWRITTEN ON THE NEXT BUILD

#nullable enable annotations

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

namespace Csp.Systems
{
    /// @ingroup Anchor System
    /// <summary>Public facing system that allows interfacing with Magnopus Connected Services' concept of an Anchor.</summary>
    /// <remarks>Offers methods for creating and deleting Anchors.</remarks>

    public class AnchorSystem : Csp.Systems.SystemBase
    {
        internal override string _safeTypeName { get; } = "csp_systems_AnchorSystem";

        #region P/Invoke
#pragma warning disable IDE1006



        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_Dtor(IntPtr @class);

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_CreateAnchor_void_AnchorProvider_StringRC_StringRC_GeoLocationRC_OlyAnchorPositionRC_OlyRotationRC_MapRC_ArrayRC_AnchorResultCallback(
            IntPtr @class,
            AnchorProvider ThirdPartyAnchorProvider,
            string ThirdPartyAnchorId,
            string AssetCollectionId,
            IntPtr Location,
            IntPtr Position,
            IntPtr Rotation,
            IntPtr SpatialKeyValue,
            IntPtr Tags,
            CreateAnchorCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_CreateAnchorInSpace_void_AnchorProvider_StringRC_StringRC_uint64_t_StringRC_GeoLocationRC_OlyAnchorPositionRC_OlyRotationRC_MapRC_ArrayRC_AnchorResultCallback(
            IntPtr @class,
            AnchorProvider ThirdPartyAnchorProvider,
            string ThirdPartyAnchorId,
            string SpaceId,
            ulong SpaceEntityId,
            string AssetCollectionId,
            IntPtr Location,
            IntPtr Position,
            IntPtr Rotation,
            IntPtr SpatialKeyValue,
            IntPtr Tags,
            CreateAnchorInSpaceCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_DeleteAnchors_void_ArrayRC_NullResultCallback(
            IntPtr @class,
            IntPtr AnchorIds,
            DeleteAnchorsCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_GetAnchorsInArea_void_GeoLocationRC_doubleC_ArrayRC_ArrayRC_ArrayRC_boolRC_ArrayRC_intRC_intRC_AnchorCollectionResultCallback(
            IntPtr @class,
            IntPtr OriginLocation,
            double AreaRadius,
            IntPtr SpatialKeys,
            IntPtr SpatialValues,
            IntPtr Tags,
            IntPtr AllTags,
            IntPtr SpaceIds,
            IntPtr Skip,
            IntPtr Limit,
            GetAnchorsInAreaCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_GetAnchorsInSpace_void_StringRC_intRC_intRC_AnchorCollectionResultCallback(
            IntPtr @class,
            string SpaceId,
            IntPtr Skip,
            IntPtr Limit,
            GetAnchorsInSpaceCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_GetAnchorsByAssetCollectionId_void_StringRC_intRC_intRC_AnchorCollectionResultCallback(
            IntPtr @class,
            string AssetCollectionId,
            IntPtr Skip,
            IntPtr Limit,
            GetAnchorsByAssetCollectionIdCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AnchorSystem_CreateAnchorResolution_void_StringRC_bool_int_double_ArrayRC_AnchorResolutionResultCallback(
            IntPtr @class,
            string AnchorId,
            bool SuccessfullyResolved,
            int ResolveAttempted,
            double ResolveTime,
            IntPtr Tags,
            CreateAnchorResolutionCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_systems_AnchorSystem_Ctor();

#pragma warning restore IDE1006
        #endregion

        internal AnchorSystem(NativePointer ptr) : base(ptr) { }

        public AnchorSystem(Csp.Systems.SystemBase baseInstance)
            : base(new NativePointer(baseInstance._ptr, baseInstance._ownsPtr ? (byte)1 : (byte)0))
        {
            // Prevent previous instance from freeing underlying pointer when destroyed
            baseInstance._ownsPtr = false;
        }

        delegate void CreateAnchorCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void CreateAnchorInSpaceCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void DeleteAnchorsCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAnchorsInAreaCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAnchorsInSpaceCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAnchorsByAssetCollectionIdCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void CreateAnchorResolutionCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        ~AnchorSystem()
        {
            //RealDispose();
        }

        void RealDispose()
        {
            if (_ownsPtr && !_disposed)
            {
                csp_systems_AnchorSystem_Dtor(_ptr);
                _disposed = true;
            }

            _disposed = true;
        }

        new public void Dispose()
        {
            RealDispose();
            GC.SuppressFinalize(this);
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (CreateAnchorCallbackDelegate))]
#endif
        static void CreateAnchorCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AnchorResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AnchorResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly CreateAnchorCallbackDelegate CreateAnchorDelegateInstance =
            CreateAnchorCallbackDelegateFunction;

        /// <summary>Creates a new Anchor.</summary>
                /// <param name="ThirdPartyAnchorProvider">The 3rd party used for the new anchor</param>
                /// <param name="ThirdPartyAnchorId">The ID of the new anchor in the 3rd party system</param>
                /// <param name="AssetCollectionId">ID of the asset collection the new anchor is associated with</param>
                /// <param name="Location">The geographical location of the new anchor</param>
                /// <param name="Position">The virtual position inside a space of the new anchor</param>
                /// <param name="Rotation">The rotation of the new anchor</param>
                /// <param name="SpatialKeyValue">Optional searchable spatialkeyvalue info to be associated with the anchor</param>
                /// <remarks>Either the value or the key can be search for.</remarks>
                /// <param name="Tags">Optional array of strings to add to the anchor as tags</param>
                /// <returns>Data class containing information on task result/progress</returns>

        public Task<Csp.Systems.AnchorResult> CreateAnchor(
            Csp.Systems.AnchorProvider ThirdPartyAnchorProvider,
            string ThirdPartyAnchorId,
            string AssetCollectionId,
            Csp.Systems.GeoLocation Location,
            Csp.Systems.OlyAnchorPosition Position,
            Csp.Systems.OlyRotation Rotation,
            Csp.Common.Map<string, string>? SpatialKeyValue,
            Csp.Common.Array<string>? Tags
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AnchorResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AnchorSystem_CreateAnchor_void_AnchorProvider_StringRC_StringRC_GeoLocationRC_OlyAnchorPositionRC_OlyRotationRC_MapRC_ArrayRC_AnchorResultCallback(
                _ptr,
                ThirdPartyAnchorProvider,
                ThirdPartyAnchorId,
                AssetCollectionId,
                Location._ptr,
                Position._ptr,
                Rotation._ptr,
                SpatialKeyValue?._ptr ?? IntPtr.Zero,
                Tags?._ptr ?? IntPtr.Zero,
                CreateAnchorDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (CreateAnchorInSpaceCallbackDelegate))]
#endif
        static void CreateAnchorInSpaceCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AnchorResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AnchorResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly CreateAnchorInSpaceCallbackDelegate CreateAnchorInSpaceDelegateInstance =
            CreateAnchorInSpaceCallbackDelegateFunction;

        /// <summary>Creates a new Anchor in a space.</summary>
                /// <param name="ThirdPartyAnchorProvider">The 3rd party used for the new anchor</param>
                /// <param name="ThirdPartyAnchorId">The ID of the new anchor in the 3rd party system</param>
                /// <param name="SpaceId">The space that the new anchor is associated with</param>
                /// <param name="SpaceEntityId">The multiplayer object the new anchor is associated with</param>
                /// <param name="AssetCollectionId">ID of the asset collection the new anchor is associated with</param>
                /// <param name="Location">The geographical location of the new anchor</param>
                /// <param name="Position">The virtual position inside a space of the new anchor</param>
                /// <param name="Rotation">The rotation of the new anchor</param>
                /// <param name="SpatialKeyValue">Optional searchable spatialkeyvalue info to be associated with the anchor</param>
                /// <remarks>Either the value or the key can be search for.</remarks>
                /// <param name="Tags">Optional array of strings to add to the anchor as tags</param>
                /// <returns>Data class containing information on task result/progress</returns>

        public Task<Csp.Systems.AnchorResult> CreateAnchorInSpace(
            Csp.Systems.AnchorProvider ThirdPartyAnchorProvider,
            string ThirdPartyAnchorId,
            string SpaceId,
            ulong SpaceEntityId,
            string AssetCollectionId,
            Csp.Systems.GeoLocation Location,
            Csp.Systems.OlyAnchorPosition Position,
            Csp.Systems.OlyRotation Rotation,
            Csp.Common.Map<string, string>? SpatialKeyValue,
            Csp.Common.Array<string>? Tags
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AnchorResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AnchorSystem_CreateAnchorInSpace_void_AnchorProvider_StringRC_StringRC_uint64_t_StringRC_GeoLocationRC_OlyAnchorPositionRC_OlyRotationRC_MapRC_ArrayRC_AnchorResultCallback(
                _ptr,
                ThirdPartyAnchorProvider,
                ThirdPartyAnchorId,
                SpaceId,
                SpaceEntityId,
                AssetCollectionId,
                Location._ptr,
                Position._ptr,
                Rotation._ptr,
                SpatialKeyValue?._ptr ?? IntPtr.Zero,
                Tags?._ptr ?? IntPtr.Zero,
                CreateAnchorInSpaceDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DeleteAnchorsCallbackDelegate))]
#endif
        static void DeleteAnchorsCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.NullResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.NullResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DeleteAnchorsCallbackDelegate DeleteAnchorsDelegateInstance =
            DeleteAnchorsCallbackDelegateFunction;

        /// <summary>Deletes a list of Anchors</summary>
                /// <param name="AnchorIds">List of Anchor IDs to be deleted</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.NullResult> DeleteAnchors(Csp.Common.Array<string> AnchorIds)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.NullResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AnchorSystem_DeleteAnchors_void_ArrayRC_NullResultCallback(
                _ptr,
                AnchorIds._ptr,
                DeleteAnchorsDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAnchorsInAreaCallbackDelegate))]
#endif
        static void GetAnchorsInAreaCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AnchorCollectionResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AnchorCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAnchorsInAreaCallbackDelegate GetAnchorsInAreaDelegateInstance =
            GetAnchorsInAreaCallbackDelegateFunction;

        /// <summary>Retrieves an array with all the Anchors that are located inside the circular area defined by the parameters</summary>
                /// <param name="OriginLocation">Latitude and longitude coordinates of the circular area origin</param>
                /// <param name="AreaRadius">Radius from the circular area origin in meters</param>
                /// <param name="SpatialKeys">Optional searchable spatialkeys info associated with the anchor</param>
                /// <param name="SpatialValues">Optional searchable spatialvalues associated with the anchor</param>
                /// <param name="Tags">Optional searchable tags info associated with the anchor</param>
                /// <param name="AllTags">Optional flag to determine of all tags must be present in anchor</param>
                /// <param name="SpaceIds">Optional array of ids of spaces to search within</param>
                /// <param name="Skip">Optional number of result entries that will be skipped from the result.</param>
                /// <param name="Limit">Optional maximum number of result entries to be retrieved. for all available result entries pass</param>
                /// <returns>Data class containing information on task result/progress</returns>

        public Task<Csp.Systems.AnchorCollectionResult> GetAnchorsInArea(
            Csp.Systems.GeoLocation OriginLocation,
            double AreaRadius,
            Csp.Common.Array<string>? SpatialKeys,
            Csp.Common.Array<string>? SpatialValues,
            Csp.Common.Array<string>? Tags,
            bool? AllTags,
            Csp.Common.Array<string>? SpaceIds,
            int? Skip,
            int? Limit
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AnchorCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            var AllTagsPointer = IntPtr.Zero;
            unsafe
            {
                if (AllTags.HasValue)
                {
                    var ptr = stackalloc bool[1];
                    *ptr = AllTags.Value;
                    AllTagsPointer = (IntPtr)ptr;
                }
            }
            var SkipPointer = IntPtr.Zero;
            unsafe
            {
                if (Skip.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = Skip.Value;
                    SkipPointer = (IntPtr)ptr;
                }
            }
            var LimitPointer = IntPtr.Zero;
            unsafe
            {
                if (Limit.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = Limit.Value;
                    LimitPointer = (IntPtr)ptr;
                }
            }

            csp_systems_AnchorSystem_GetAnchorsInArea_void_GeoLocationRC_doubleC_ArrayRC_ArrayRC_ArrayRC_boolRC_ArrayRC_intRC_intRC_AnchorCollectionResultCallback(
                _ptr,
                OriginLocation._ptr,
                AreaRadius,
                SpatialKeys?._ptr ?? IntPtr.Zero,
                SpatialValues?._ptr ?? IntPtr.Zero,
                Tags?._ptr ?? IntPtr.Zero,
                AllTagsPointer,
                SpaceIds?._ptr ?? IntPtr.Zero,
                SkipPointer,
                LimitPointer,
                GetAnchorsInAreaDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAnchorsInSpaceCallbackDelegate))]
#endif
        static void GetAnchorsInSpaceCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AnchorCollectionResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AnchorCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAnchorsInSpaceCallbackDelegate GetAnchorsInSpaceDelegateInstance =
            GetAnchorsInSpaceCallbackDelegateFunction;

        /// <summary>Retrieves an array with all the Anchors that are located inside the given space</summary>
                /// <param name="SpaceId">Id of the space to search within</param>
                /// <param name="Skip">Optional number of result entries that will be skipped from the result.</param>
                /// <param name="Limit">Optional maximum number of result entries to be retrieved. for all available result entries pass</param>
                /// <returns>Data class containing information on task result/progress</returns>

        public Task<Csp.Systems.AnchorCollectionResult> GetAnchorsInSpace(string SpaceId, int? Skip, int? Limit)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AnchorCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            var SkipPointer = IntPtr.Zero;
            unsafe
            {
                if (Skip.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = Skip.Value;
                    SkipPointer = (IntPtr)ptr;
                }
            }
            var LimitPointer = IntPtr.Zero;
            unsafe
            {
                if (Limit.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = Limit.Value;
                    LimitPointer = (IntPtr)ptr;
                }
            }

            csp_systems_AnchorSystem_GetAnchorsInSpace_void_StringRC_intRC_intRC_AnchorCollectionResultCallback(
                _ptr,
                SpaceId,
                SkipPointer,
                LimitPointer,
                GetAnchorsInSpaceDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAnchorsByAssetCollectionIdCallbackDelegate))]
#endif
        static void GetAnchorsByAssetCollectionIdCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AnchorCollectionResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AnchorCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAnchorsByAssetCollectionIdCallbackDelegate GetAnchorsByAssetCollectionIdDelegateInstance =
            GetAnchorsByAssetCollectionIdCallbackDelegateFunction;

        /// <summary>Retrieves a list of Anchors that belong to the given AssetCollection</summary>
                /// <param name="AssetCollectionId">Id of the assetcollection to filter by</param>
                /// <returns>Data class containing information on task result/progress</returns>

        public Task<Csp.Systems.AnchorCollectionResult> GetAnchorsByAssetCollectionId(
            string AssetCollectionId,
            int? Skip,
            int? Limit
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AnchorCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            var SkipPointer = IntPtr.Zero;
            unsafe
            {
                if (Skip.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = Skip.Value;
                    SkipPointer = (IntPtr)ptr;
                }
            }
            var LimitPointer = IntPtr.Zero;
            unsafe
            {
                if (Limit.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = Limit.Value;
                    LimitPointer = (IntPtr)ptr;
                }
            }

            csp_systems_AnchorSystem_GetAnchorsByAssetCollectionId_void_StringRC_intRC_intRC_AnchorCollectionResultCallback(
                _ptr,
                AssetCollectionId,
                SkipPointer,
                LimitPointer,
                GetAnchorsByAssetCollectionIdDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (CreateAnchorResolutionCallbackDelegate))]
#endif
        static void CreateAnchorResolutionCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AnchorResolutionResult>)_handle.Target;
            var _this = (AnchorSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AnchorResolutionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly CreateAnchorResolutionCallbackDelegate CreateAnchorResolutionDelegateInstance =
            CreateAnchorResolutionCallbackDelegateFunction;

        /// <summary>Creates a new AnchorResolution.</summary>
                /// <param name="AnchorId">Anchor Id to associate AnchorResolution with</param>
                /// <param name="SuccessfullyResolved">Successfully resolved value for an anchor</param>
                /// <param name="ResolveAttempted">Number of resolve attempted for an anchor</param>
                /// <param name="ResolveTime">Resolve time of anchor in seconds</param>
                /// <param name="Tags">Optional searchable tags info associated with the anchorresolution</param>
                /// <returns>Data class containing information on task result/progress</returns>

        public Task<Csp.Systems.AnchorResolutionResult> CreateAnchorResolution(
            string AnchorId,
            bool SuccessfullyResolved,
            int ResolveAttempted,
            double ResolveTime,
            Csp.Common.Array<string> Tags
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AnchorResolutionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AnchorSystem_CreateAnchorResolution_void_StringRC_bool_int_double_ArrayRC_AnchorResolutionResultCallback(
                _ptr,
                AnchorId,
                SuccessfullyResolved,
                ResolveAttempted,
                ResolveTime,
                Tags._ptr,
                CreateAnchorResolutionDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

        protected AnchorSystem() { }
    }
}

