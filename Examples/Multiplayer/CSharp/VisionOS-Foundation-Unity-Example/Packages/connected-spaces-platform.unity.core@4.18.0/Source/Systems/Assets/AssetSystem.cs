// WARNING: DO NOT EDIT THIS FILE! IT IS A GENERATED FILE AND
//   ANY CHANGES YOU MAKE WILL BE OVERWRITTEN ON THE NEXT BUILD

#nullable enable annotations

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

namespace Csp.Systems
{
    /// @ingroup Asset System
    /// <summary>Public facing system that allows uploading/downloading and creation of assets.</summary>

    public class AssetSystem : Csp.Systems.SystemBase
    {
        internal override string _safeTypeName { get; } = "csp_systems_AssetSystem";

        #region P/Invoke
#pragma warning disable IDE1006



        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_Dtor(IntPtr @class);

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_CreateAssetCollection_void_StringRC_StringRC_StringRC_MapRC_EAssetCollectionTypeC_ArrayRC_AssetCollectionResultCallback(
            IntPtr @class,
            string SpaceId,
            string ParentAssetCollectionId,
            string AssetCollectionName,
            IntPtr Metadata,
            EAssetCollectionType Type,
            IntPtr Tags,
            CreateAssetCollectionCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_DeleteAssetCollection_void_AssetCollectionRC_NullResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            DeleteAssetCollectionCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetCollectionById_void_StringRC_AssetCollectionResultCallback(
            IntPtr @class,
            string AssetCollectionId,
            GetAssetCollectionByIdCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetCollectionByName_void_StringRC_AssetCollectionResultCallback(
            IntPtr @class,
            string AssetCollectionName,
            GetAssetCollectionByNameCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetCollectionsByIds_void_ArrayRC_AssetCollectionsResultCallback(
            IntPtr @class,
            IntPtr AssetCollectionIds,
            GetAssetCollectionsByIdsCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetCollectionsByCriteria_void_StringRC_StringRC_EAssetCollectionTypeRC_ArrayRC_ArrayRC_intRC_intRC_AssetCollectionsResultCallback(
            IntPtr @class,
            string SpaceId,
            string AssetCollectionParentId,
            IntPtr AssetCollectionType,
            IntPtr AssetCollectionTags,
            IntPtr AssetCollectionNames,
            IntPtr ResultsSkipNumber,
            IntPtr ResultsMaxNumber,
            GetAssetCollectionsByCriteriaCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_UpdateAssetCollectionMetadata_void_AssetCollectionRC_MapRC_AssetCollectionResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            IntPtr NewMetadata,
            UpdateAssetCollectionMetadataCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_CreateAsset_void_AssetCollectionRC_StringRC_StringRC_EThirdPartyPlatformRC_EAssetType_AssetResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            string Name,
            string ThirdPartyPackagedAssetIdentifier,
            IntPtr ThirdPartyPlatform,
            EAssetType Type,
            CreateAssetCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_UpdateAsset_void_AssetRC_AssetResultCallback(
            IntPtr @class,
            IntPtr Asset,
            UpdateAssetCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_DeleteAsset_void_AssetCollectionRC_AssetRC_NullResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            IntPtr Asset,
            DeleteAssetCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetsInCollection_void_AssetCollectionRC_AssetsResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            GetAssetsInCollectionCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetById_void_StringRC_StringRC_AssetResultCallback(
            IntPtr @class,
            string AssetCollectionId,
            string AssetId,
            GetAssetByIdCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetsByCollectionIds_void_ArrayRC_AssetsResultCallback(
            IntPtr @class,
            IntPtr AssetCollectionIds,
            GetAssetsByCollectionIdsCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetsByCriteria_void_ArrayRC_ArrayRC_ArrayRC_ArrayRC_AssetsResultCallback(
            IntPtr @class,
            IntPtr AssetCollectionIds,
            IntPtr AssetIds,
            IntPtr AssetNames,
            IntPtr AssetTypes,
            GetAssetsByCriteriaCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_UploadAssetData_void_AssetCollectionRC_AssetRC_AssetDataSourceRC_UriResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            IntPtr Asset,
            IntPtr AssetDataSource,
            UploadAssetDataCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_UploadAssetDataEx_void_AssetCollectionRC_AssetRC_AssetDataSourceRC_CancellationTokenR_UriResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            IntPtr Asset,
            IntPtr AssetDataSource,
            IntPtr CancellationToken,
            UploadAssetDataExCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_DownloadAssetData_void_AssetRC_AssetDataResultCallback(
            IntPtr @class,
            IntPtr Asset,
            DownloadAssetDataCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_DownloadAssetDataEx_void_AssetRC_CancellationTokenR_AssetDataResultCallback(
            IntPtr @class,
            IntPtr Asset,
            IntPtr CancellationToken,
            DownloadAssetDataExCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetAssetDataSize_void_AssetRC_UInt64ResultCallback(
            IntPtr @class,
            IntPtr Asset,
            GetAssetDataSizeCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_GetLODChain_void_AssetCollectionRC_LODChainResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            GetLODChainCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_systems_AssetSystem_RegisterAssetToLODChain_void_AssetCollectionRC_AssetRC_int_AssetResultCallback(
            IntPtr @class,
            IntPtr AssetCollection,
            IntPtr Asset,
            int LODLevel,
            RegisterAssetToLODChainCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_systems_AssetSystem_Ctor();

#pragma warning restore IDE1006
        #endregion

        internal AssetSystem(NativePointer ptr) : base(ptr) { }

        public AssetSystem(Csp.Systems.SystemBase baseInstance)
            : base(new NativePointer(baseInstance._ptr, baseInstance._ownsPtr ? (byte)1 : (byte)0))
        {
            // Prevent previous instance from freeing underlying pointer when destroyed
            baseInstance._ownsPtr = false;
        }

        delegate void CreateAssetCollectionCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void DeleteAssetCollectionCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetCollectionByIdCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetCollectionByNameCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetCollectionsByIdsCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetCollectionsByCriteriaCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void UpdateAssetCollectionMetadataCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void CreateAssetCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void UpdateAssetCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void DeleteAssetCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetsInCollectionCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetByIdCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetsByCollectionIdsCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetsByCriteriaCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void UploadAssetDataCallbackDelegate(IntPtr _StateObject__, NativePointer Result);
        public event EventHandler<ProgressEventArgs>? UploadAssetDataOnProgress;

        delegate void UploadAssetDataExCallbackDelegate(IntPtr _StateObject__, NativePointer Result);
        public event EventHandler<ProgressEventArgs>? UploadAssetDataExOnProgress;

        delegate void DownloadAssetDataCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void DownloadAssetDataExCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetAssetDataSizeCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetLODChainCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void RegisterAssetToLODChainCallbackDelegate(IntPtr _StateObject__, NativePointer Result);
        public event EventHandler<ProgressEventArgs>? RegisterAssetToLODChainOnProgress;

        ~AssetSystem()
        {
            //RealDispose();
        }

        void RealDispose()
        {
            if (_ownsPtr && !_disposed)
            {
                csp_systems_AssetSystem_Dtor(_ptr);
                _disposed = true;
            }

            _disposed = true;
        }

        new public void Dispose()
        {
            RealDispose();
            GC.SuppressFinalize(this);
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (CreateAssetCollectionCallbackDelegate))]
#endif
        static void CreateAssetCollectionCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetCollectionResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly CreateAssetCollectionCallbackDelegate CreateAssetCollectionDelegateInstance =
            CreateAssetCollectionCallbackDelegateFunction;

        /// <summary>Creates an asset collection.</summary>
                /// <param name="Space">Optional space to associate the asset collection with</param>
                /// <param name="ParentAssetCollectionId">Optional parent asset collection id</param>
                /// <param name="AssetCollectionName">Name of the asset collection</param>
                /// <param name="Metadata">Optional metadata info to be associated with the asset collection</param>
                /// <param name="Type">Type of the new asset collection</param>
                /// <param name="Tags">Optional array of strings to add to the asset collection as tags</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetCollectionResult> CreateAssetCollection(
            string? SpaceId,
            string? ParentAssetCollectionId,
            string AssetCollectionName,
            Csp.Common.Map<string, string>? Metadata,
            Csp.Systems.EAssetCollectionType Type,
            Csp.Common.Array<string>? Tags
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_CreateAssetCollection_void_StringRC_StringRC_StringRC_MapRC_EAssetCollectionTypeC_ArrayRC_AssetCollectionResultCallback(
                _ptr,
                SpaceId,
                ParentAssetCollectionId,
                AssetCollectionName,
                Metadata?._ptr ?? IntPtr.Zero,
                Type,
                Tags?._ptr ?? IntPtr.Zero,
                CreateAssetCollectionDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DeleteAssetCollectionCallbackDelegate))]
#endif
        static void DeleteAssetCollectionCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.NullResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.NullResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DeleteAssetCollectionCallbackDelegate DeleteAssetCollectionDelegateInstance =
            DeleteAssetCollectionCallbackDelegateFunction;

        /// <summary>Deletes a given asset collection.</summary>
                /// <param name="AssetCollection">Asset collection to delete</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.NullResult> DeleteAssetCollection(Csp.Systems.AssetCollection AssetCollection)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.NullResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_DeleteAssetCollection_void_AssetCollectionRC_NullResultCallback(
                _ptr,
                AssetCollection._ptr,
                DeleteAssetCollectionDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetCollectionByIdCallbackDelegate))]
#endif
        static void GetAssetCollectionByIdCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetCollectionResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetCollectionByIdCallbackDelegate GetAssetCollectionByIdDelegateInstance =
            GetAssetCollectionByIdCallbackDelegateFunction;

        /// <summary>Finds an asset collection by its Id.</summary>
                /// <param name="AssetCollectionId">Asset collection to delete</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetCollectionResult> GetAssetCollectionById(string AssetCollectionId)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetCollectionById_void_StringRC_AssetCollectionResultCallback(
                _ptr,
                AssetCollectionId,
                GetAssetCollectionByIdDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetCollectionByNameCallbackDelegate))]
#endif
        static void GetAssetCollectionByNameCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetCollectionResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetCollectionByNameCallbackDelegate GetAssetCollectionByNameDelegateInstance =
            GetAssetCollectionByNameCallbackDelegateFunction;

        /// <summary>Finds an asset collection by its Name.</summary>
                /// <param name="AssetCollectionName">Name of the asset collection to be retrieved</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetCollectionResult> GetAssetCollectionByName(string AssetCollectionName)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetCollectionByName_void_StringRC_AssetCollectionResultCallback(
                _ptr,
                AssetCollectionName,
                GetAssetCollectionByNameDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetCollectionsByIdsCallbackDelegate))]
#endif
        static void GetAssetCollectionsByIdsCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetCollectionsResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetCollectionsResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetCollectionsByIdsCallbackDelegate GetAssetCollectionsByIdsDelegateInstance =
            GetAssetCollectionsByIdsCallbackDelegateFunction;

        /// <summary>Finds a collection of asset collections by their Ids.</summary>
                /// <param name="AssetCollectionIds">An array of ids to search for</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetCollectionsResult> GetAssetCollectionsByIds(
            Csp.Common.Array<string> AssetCollectionIds
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetCollectionsResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetCollectionsByIds_void_ArrayRC_AssetCollectionsResultCallback(
                _ptr,
                AssetCollectionIds._ptr,
                GetAssetCollectionsByIdsDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetCollectionsByCriteriaCallbackDelegate))]
#endif
        static void GetAssetCollectionsByCriteriaCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetCollectionsResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetCollectionsResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetCollectionsByCriteriaCallbackDelegate GetAssetCollectionsByCriteriaDelegateInstance =
            GetAssetCollectionsByCriteriaCallbackDelegateFunction;

        /// <summary>Retrieves asset collections based on the specified search criteria.</summary>
                /// <remarks>Results pagination is supported through the use of ResultsSkipNumber and ResultsMaxNumber.</remarks>
                /// <param name="Space">Optional space to get asset collections associated with it</param>
                /// <param name="AssetCollectionParentId">Optional asset collection parent id to get asset collections associated with it</param>
                /// <param name="AssetCollectionType">Type of the asset collection</param>
                /// <param name="AssetCollectionTags">Optional array of strings representing asset collection tags</param>
                /// <param name="AssetCollectionNames">Optional array of strings representing asset</param>
                /// <remarks>collection names</remarks>
                /// <param name="ResultsSkipNumber">Optional param representing the number of result entries that will be skipped from the result. for no skip pass</param>
                /// <remarks>nullptr.</remarks>
                /// <param name="ResultsMaxNumber">Optional param representing the maximum number of result entries to be retrieved. for all available result</param>
                /// <remarks>entries pass nullptr.</remarks>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetCollectionsResult> GetAssetCollectionsByCriteria(
            string? SpaceId,
            string? AssetCollectionParentId,
            Csp.Systems.EAssetCollectionType? AssetCollectionType,
            Csp.Common.Array<string>? AssetCollectionTags,
            Csp.Common.Array<string>? AssetCollectionNames,
            int? ResultsSkipNumber,
            int? ResultsMaxNumber
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetCollectionsResult>(this);
            var handle = GCHandle.Alloc(tcs);

            var AssetCollectionTypePointer = IntPtr.Zero;
            unsafe
            {
                if (AssetCollectionType.HasValue)
                {
                    var ptr = stackalloc Csp.Systems.EAssetCollectionType[1];
                    *ptr = AssetCollectionType.Value;
                    AssetCollectionTypePointer = (IntPtr)ptr;
                }
            }
            var ResultsSkipNumberPointer = IntPtr.Zero;
            unsafe
            {
                if (ResultsSkipNumber.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = ResultsSkipNumber.Value;
                    ResultsSkipNumberPointer = (IntPtr)ptr;
                }
            }
            var ResultsMaxNumberPointer = IntPtr.Zero;
            unsafe
            {
                if (ResultsMaxNumber.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = ResultsMaxNumber.Value;
                    ResultsMaxNumberPointer = (IntPtr)ptr;
                }
            }

            csp_systems_AssetSystem_GetAssetCollectionsByCriteria_void_StringRC_StringRC_EAssetCollectionTypeRC_ArrayRC_ArrayRC_intRC_intRC_AssetCollectionsResultCallback(
                _ptr,
                SpaceId,
                AssetCollectionParentId,
                AssetCollectionTypePointer,
                AssetCollectionTags?._ptr ?? IntPtr.Zero,
                AssetCollectionNames?._ptr ?? IntPtr.Zero,
                ResultsSkipNumberPointer,
                ResultsMaxNumberPointer,
                GetAssetCollectionsByCriteriaDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (UpdateAssetCollectionMetadataCallbackDelegate))]
#endif
        static void UpdateAssetCollectionMetadataCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetCollectionResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly UpdateAssetCollectionMetadataCallbackDelegate UpdateAssetCollectionMetadataDelegateInstance =
            UpdateAssetCollectionMetadataCallbackDelegateFunction;

        /// <summary>Updates the Metadata field of an Asset Collection</summary>
                /// <param name="AssetCollection">Asset collection to be updated</param>
                /// <param name="NewMetadata">The new metadata information that will replace the previous</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetCollectionResult> UpdateAssetCollectionMetadata(
            Csp.Systems.AssetCollection AssetCollection,
            Csp.Common.Map<string, string> NewMetadata
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_UpdateAssetCollectionMetadata_void_AssetCollectionRC_MapRC_AssetCollectionResultCallback(
                _ptr,
                AssetCollection._ptr,
                NewMetadata._ptr,
                UpdateAssetCollectionMetadataDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (CreateAssetCallbackDelegate))]
#endif
        static void CreateAssetCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly CreateAssetCallbackDelegate CreateAssetDelegateInstance = CreateAssetCallbackDelegateFunction;

        /// <summary>Creates a new asset.</summary>
                /// <param name="AssetCollection">The parent collection for the asset to be associated with</param>
                /// <param name="Name">Name of the asset collection</param>
                /// <param name="ThirdPartyPackagedAssetIdentifier">Optional id to a third party packaged asset identifier</param>
                /// <param name="ThirdPartyPlatform">Optional enum class for third part platform</param>
                /// <param name="Type">Type of the asset</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetResult> CreateAsset(
            Csp.Systems.AssetCollection AssetCollection,
            string Name,
            string? ThirdPartyPackagedAssetIdentifier,
            Csp.Systems.EThirdPartyPlatform? ThirdPartyPlatform,
            Csp.Systems.EAssetType Type
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetResult>(this);
            var handle = GCHandle.Alloc(tcs);

            var ThirdPartyPlatformPointer = IntPtr.Zero;
            unsafe
            {
                if (ThirdPartyPlatform.HasValue)
                {
                    var ptr = stackalloc Csp.Systems.EThirdPartyPlatform[1];
                    *ptr = ThirdPartyPlatform.Value;
                    ThirdPartyPlatformPointer = (IntPtr)ptr;
                }
            }

            csp_systems_AssetSystem_CreateAsset_void_AssetCollectionRC_StringRC_StringRC_EThirdPartyPlatformRC_EAssetType_AssetResultCallback(
                _ptr,
                AssetCollection._ptr,
                Name,
                ThirdPartyPackagedAssetIdentifier,
                ThirdPartyPlatformPointer,
                Type,
                CreateAssetDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (UpdateAssetCallbackDelegate))]
#endif
        static void UpdateAssetCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly UpdateAssetCallbackDelegate UpdateAssetDelegateInstance = UpdateAssetCallbackDelegateFunction;

        /// <summary>Update a given asset.</summary>
                /// <param name="Asset">Asset to update</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetResult> UpdateAsset(Csp.Systems.Asset Asset)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_UpdateAsset_void_AssetRC_AssetResultCallback(
                _ptr,
                Asset._ptr,
                UpdateAssetDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DeleteAssetCallbackDelegate))]
#endif
        static void DeleteAssetCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.NullResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.NullResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DeleteAssetCallbackDelegate DeleteAssetDelegateInstance = DeleteAssetCallbackDelegateFunction;

        /// <summary>Deletes a given asset.</summary>
                /// <param name="AssetCollection">The parent collection that the asset is associated with</param>
                /// <param name="Asset">Asset to delete</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.NullResult> DeleteAsset(
            Csp.Systems.AssetCollection AssetCollection,
            Csp.Systems.Asset Asset
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.NullResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_DeleteAsset_void_AssetCollectionRC_AssetRC_NullResultCallback(
                _ptr,
                AssetCollection._ptr,
                Asset._ptr,
                DeleteAssetDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetsInCollectionCallbackDelegate))]
#endif
        static void GetAssetsInCollectionCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetsResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetsResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetsInCollectionCallbackDelegate GetAssetsInCollectionDelegateInstance =
            GetAssetsInCollectionCallbackDelegateFunction;

        /// <summary>Retrieves all assets in a given asset collection.</summary>
                /// <param name="AssetCollection">Collection to get all assets from</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetsResult> GetAssetsInCollection(Csp.Systems.AssetCollection AssetCollection)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetsResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetsInCollection_void_AssetCollectionRC_AssetsResultCallback(
                _ptr,
                AssetCollection._ptr,
                GetAssetsInCollectionDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetByIdCallbackDelegate))]
#endif
        static void GetAssetByIdCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetByIdCallbackDelegate GetAssetByIdDelegateInstance =
            GetAssetByIdCallbackDelegateFunction;

        /// <summary>Retrieves the asset specified by the Id</summary>
                /// <param name="AssetCollectionId">The id of the asset collection containing the asset</param>
                /// <param name="AssetId">The id of the asset to retrieve</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetResult> GetAssetById(string AssetCollectionId, string AssetId)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetById_void_StringRC_StringRC_AssetResultCallback(
                _ptr,
                AssetCollectionId,
                AssetId,
                GetAssetByIdDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetsByCollectionIdsCallbackDelegate))]
#endif
        static void GetAssetsByCollectionIdsCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetsResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetsResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetsByCollectionIdsCallbackDelegate GetAssetsByCollectionIdsDelegateInstance =
            GetAssetsByCollectionIdsCallbackDelegateFunction;

        /// <summary>Retrieves all assets that belong to the asset collections with the give Ids.</summary>
                /// <param name="AssetCollectionIds">Collection of asset collection ids get all assets from</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetsResult> GetAssetsByCollectionIds(Csp.Common.Array<string> AssetCollectionIds)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetsResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetsByCollectionIds_void_ArrayRC_AssetsResultCallback(
                _ptr,
                AssetCollectionIds._ptr,
                GetAssetsByCollectionIdsDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetsByCriteriaCallbackDelegate))]
#endif
        static void GetAssetsByCriteriaCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetsResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetsResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetsByCriteriaCallbackDelegate GetAssetsByCriteriaDelegateInstance =
            GetAssetsByCriteriaCallbackDelegateFunction;

        /// <summary>Retrieves assets based on the specified search criteria.</summary>
                /// <param name="AssetCollectionIds">The asset collection ids that will be used as search criteria. note that</param>
                /// <remarks>you have to pass at least one Id.</remarks>
                /// <param name="AssetIds">Optional array of strings representing asset ids</param>
                /// <param name="AssetNames">Optional array of strings representing asset names</param>
                /// <param name="AssetTypes">Optional array of asset types</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetsResult> GetAssetsByCriteria(
            Csp.Common.Array<string> AssetCollectionIds,
            Csp.Common.Array<string>? AssetIds,
            Csp.Common.Array<string>? AssetNames,
            Csp.Common.Array<Csp.Systems.EAssetType>? AssetTypes
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetsResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetsByCriteria_void_ArrayRC_ArrayRC_ArrayRC_ArrayRC_AssetsResultCallback(
                _ptr,
                AssetCollectionIds._ptr,
                AssetIds?._ptr ?? IntPtr.Zero,
                AssetNames?._ptr ?? IntPtr.Zero,
                AssetTypes?._ptr ?? IntPtr.Zero,
                GetAssetsByCriteriaDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (UploadAssetDataCallbackDelegate))]
#endif
        static void UploadAssetDataCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.UriResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.UriResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                _this.UploadAssetDataOnProgress?.Invoke(_this, new ProgressEventArgs(task_result.GetRequestProgress()));

                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly UploadAssetDataCallbackDelegate UploadAssetDataDelegateInstance =
            UploadAssetDataCallbackDelegateFunction;

        /// <summary>Uploads data for the given asset to CHS from the given source.</summary>
                /// <param name="AssetCollection">Collection the asset is associated to</param>
                /// <param name="Asset">Asset to upload data for</param>
                /// <param name="AssetDataSource">Asset data to upload</param>
                /// <remarks>AssetDataSource is an interface. A derived class must be passed.</remarks>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.UriResult> UploadAssetData(
            Csp.Systems.AssetCollection AssetCollection,
            Csp.Systems.Asset Asset,
            Csp.Systems.AssetDataSource AssetDataSource
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.UriResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_UploadAssetData_void_AssetCollectionRC_AssetRC_AssetDataSourceRC_UriResultCallback(
                _ptr,
                AssetCollection._ptr,
                Asset._ptr,
                ((NativeClassWrapper)AssetDataSource)._ptr,
                UploadAssetDataDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (UploadAssetDataExCallbackDelegate))]
#endif
        static void UploadAssetDataExCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.UriResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.UriResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                _this.UploadAssetDataExOnProgress?.Invoke(
                    _this,
                    new ProgressEventArgs(task_result.GetRequestProgress())
                );

                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly UploadAssetDataExCallbackDelegate UploadAssetDataExDelegateInstance =
            UploadAssetDataExCallbackDelegateFunction;

        /// <summary>Uploads data for the given asset to CHS from the given source, taking a CancellationToken to allow cancelling the request.</summary>
                /// <param name="AssetCollection">Collection the asset is associated to</param>
                /// <param name="Asset">Asset to upload data for</param>
                /// <param name="AssetDataSource">Asset data to upload</param>
                /// <remarks>AssetDataSource is an interface. A derived class must be passed.</remarks>
                /// <param name="CancellationToken">Token for cancelling upload</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.UriResult> UploadAssetDataEx(
            Csp.Systems.AssetCollection AssetCollection,
            Csp.Systems.Asset Asset,
            Csp.Systems.AssetDataSource AssetDataSource,
            Csp.Common.CancellationToken CancellationToken
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.UriResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_UploadAssetDataEx_void_AssetCollectionRC_AssetRC_AssetDataSourceRC_CancellationTokenR_UriResultCallback(
                _ptr,
                AssetCollection._ptr,
                Asset._ptr,
                ((NativeClassWrapper)AssetDataSource)._ptr,
                CancellationToken._ptr,
                UploadAssetDataExDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DownloadAssetDataCallbackDelegate))]
#endif
        static void DownloadAssetDataCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetDataResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetDataResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DownloadAssetDataCallbackDelegate DownloadAssetDataDelegateInstance =
            DownloadAssetDataCallbackDelegateFunction;

        /// <summary>Downloads data for a given Asset from CHS.</summary>
                /// <param name="Asset">Asset to download data for</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetDataResult> DownloadAssetData(Csp.Systems.Asset Asset)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetDataResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_DownloadAssetData_void_AssetRC_AssetDataResultCallback(
                _ptr,
                Asset._ptr,
                DownloadAssetDataDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DownloadAssetDataExCallbackDelegate))]
#endif
        static void DownloadAssetDataExCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetDataResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetDataResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DownloadAssetDataExCallbackDelegate DownloadAssetDataExDelegateInstance =
            DownloadAssetDataExCallbackDelegateFunction;

        /// <summary>Downloads data for a given Asset from CHS, taking a CancellationToken to allow cancelling the request.</summary>
                /// <param name="Asset">Asset to download data for</param>
                /// <param name="CancellationToken">Token for cancelling download</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetDataResult> DownloadAssetDataEx(
            Csp.Systems.Asset Asset,
            Csp.Common.CancellationToken CancellationToken
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetDataResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_DownloadAssetDataEx_void_AssetRC_CancellationTokenR_AssetDataResultCallback(
                _ptr,
                Asset._ptr,
                CancellationToken._ptr,
                DownloadAssetDataExDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetAssetDataSizeCallbackDelegate))]
#endif
        static void GetAssetDataSizeCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.UInt64Result>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.UInt64Result(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetAssetDataSizeCallbackDelegate GetAssetDataSizeDelegateInstance =
            GetAssetDataSizeCallbackDelegateFunction;

        /// <summary>Get the size of the data associated with an Asset.</summary>
                /// <param name="Asset">Asset to get data size for</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.UInt64Result> GetAssetDataSize(Csp.Systems.Asset Asset)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.UInt64Result>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetAssetDataSize_void_AssetRC_UInt64ResultCallback(
                _ptr,
                Asset._ptr,
                GetAssetDataSizeDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetLODChainCallbackDelegate))]
#endif
        static void GetLODChainCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.LODChainResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.LODChainResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetLODChainCallbackDelegate GetLODChainDelegateInstance = GetLODChainCallbackDelegateFunction;

        /// <summary>Gets a LOD chain within the given AssetCollection.</summary>
                /// <param name="AssetCollection">AssetCollection which contains the LOD chain.</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.LODChainResult> GetLODChain(Csp.Systems.AssetCollection AssetCollection)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.LODChainResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_GetLODChain_void_AssetCollectionRC_LODChainResultCallback(
                _ptr,
                AssetCollection._ptr,
                GetLODChainDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (RegisterAssetToLODChainCallbackDelegate))]
#endif
        static void RegisterAssetToLODChainCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.AssetResult>)_handle.Target;
            var _this = (AssetSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.AssetResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                _this.RegisterAssetToLODChainOnProgress?.Invoke(
                    _this,
                    new ProgressEventArgs(task_result.GetRequestProgress())
                );

                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly RegisterAssetToLODChainCallbackDelegate RegisterAssetToLODChainDelegateInstance =
            RegisterAssetToLODChainCallbackDelegateFunction;

        /// <summary>Registers an asset to the LOD chain</summary>
                /// <param name="AssetCollection">AssetCollection which contains the LOD chain.</param>
                /// <param name="Asset">Asset to register as LOD</param>
                /// <param name="Asset">LOD level for Asset to be registered to</param>
                /// <returns>Result class</returns>

        public Task<Csp.Systems.AssetResult> RegisterAssetToLODChain(
            Csp.Systems.AssetCollection AssetCollection,
            Csp.Systems.Asset Asset,
            int LODLevel
        ) {
            var tcs = new TaskCompletionSource<Csp.Systems.AssetResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_systems_AssetSystem_RegisterAssetToLODChain_void_AssetCollectionRC_AssetRC_int_AssetResultCallback(
                _ptr,
                AssetCollection._ptr,
                Asset._ptr,
                LODLevel,
                RegisterAssetToLODChainDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

        protected AssetSystem() { }
    }
}

