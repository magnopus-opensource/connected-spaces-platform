// WARNING: DO NOT EDIT THIS FILE! IT IS A GENERATED FILE AND
//   ANY CHANGES YOU MAKE WILL BE OVERWRITTEN ON THE NEXT BUILD

#nullable enable annotations

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

namespace Csp.Common
{
    static class MapDelegates
    {
        public delegate NativePointer csp_common_Map_CtorDelegate();
        public delegate NativePointer csp_common_Map_Ctor_MapRCDelegate(IntPtr Other);
        public delegate void csp_common_Map_DtorDelegate(IntPtr @class);
        public delegate NativePointer csp_common_Map_op_Index_TValueR_TKeyRC_GetDelegate(IntPtr @class, IntPtr Key);
        public delegate void csp_common_Map_op_Index_TValueR_TKeyRC_SetDelegate(
            IntPtr @class,
            IntPtr Key,
            IntPtr value
        );
        public delegate ulong csp_common_Map_SizeC_size_tDelegate(IntPtr @class);
        public delegate bool csp_common_Map_HasKeyC_bool_TKeyRCDelegate(IntPtr @class, IntPtr Key);
        public delegate NativePointer csp_common_Map_KeysC_ArrayPCDelegate(IntPtr @class);
        public delegate NativePointer csp_common_Map_ValuesC_ArrayPCDelegate(IntPtr @class);
        public delegate void csp_common_Map_Remove_void_TKeyRCDelegate(IntPtr @class, IntPtr Key);
        public delegate void csp_common_Map_Clear_voidDelegate(IntPtr @class);
    }

    public class Map<TKey, TValue> : NativeClassWrapper, IDisposable
    {
        string __safeTypeName;
        internal override string _safeTypeName
        {
            get => __safeTypeName;
        }

        MapDelegates.csp_common_Map_CtorDelegate csp_common_Map_Ctor;
        MapDelegates.csp_common_Map_Ctor_MapRCDelegate csp_common_Map_Ctor_MapRC;
        MapDelegates.csp_common_Map_DtorDelegate csp_common_Map_Dtor;
        MapDelegates.csp_common_Map_op_Index_TValueR_TKeyRC_GetDelegate csp_common_Map_op_Index_TValueR_TKeyRC_Get;
        MapDelegates.csp_common_Map_op_Index_TValueR_TKeyRC_SetDelegate csp_common_Map_op_Index_TValueR_TKeyRC_Set;
        MapDelegates.csp_common_Map_SizeC_size_tDelegate csp_common_Map_SizeC_size_t;
        MapDelegates.csp_common_Map_HasKeyC_bool_TKeyRCDelegate csp_common_Map_HasKeyC_bool_TKeyRC;
        MapDelegates.csp_common_Map_KeysC_ArrayPCDelegate csp_common_Map_KeysC_ArrayPC;
        MapDelegates.csp_common_Map_ValuesC_ArrayPCDelegate csp_common_Map_ValuesC_ArrayPC;
        MapDelegates.csp_common_Map_Remove_void_TKeyRCDelegate csp_common_Map_Remove_void_TKeyRC;
        MapDelegates.csp_common_Map_Clear_voidDelegate csp_common_Map_Clear_void;

        readonly bool IsTKeyProxyClass,
            IsTValueProxyClass;

        void InitialiseNativeDelegates()
        {
            // TODO: Move this stuff into a static dictionary so we don't have to create instances to get the string
            //  eg.
            //  static class TemplateMetadata {
            //    public static Dictionary<Type, string> SafeNames = {
            //      [typeof(Csp.Systems.Anchor)] = "csp_systems_Anchor"
            //    };
            //
            //    /* Delegates here for template instance functions */
            //  }
            const BindingFlags ctorBindingFlags =
                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            var ctorArgs = new object[] { NativePointer.Zero };

            string TKeyTypeName;

            if (typeof(NativeClassWrapper).IsAssignableFrom(typeof(TKey)))
            {
                var instance = Activator.CreateInstance(typeof(TKey), ctorBindingFlags, null, ctorArgs, null);
                TKeyTypeName = ((NativeClassWrapper)instance)._safeTypeName;
            }
            else if (typeof(TKey).IsEnum)
            {
                TKeyTypeName = typeof(TKey).Namespace switch
                {
                    "Csp" => "csp_",
                    "Csp.Common" => "csp_common_",
                    "Csp.Systems" => "csp_systems_",
                    "Csp.Multiplayer" => "csp_multiplayer_",
                    _ => throw new Exception("Unknown enum namespace!"),
                };
                TKeyTypeName += typeof(TKey).Name;
            }
            else
                TKeyTypeName = typeof(TKey).Name;

            string TValueTypeName;

            if (typeof(NativeClassWrapper).IsAssignableFrom(typeof(TValue)))
            {
                var instance = Activator.CreateInstance(typeof(TValue), ctorBindingFlags, null, ctorArgs, null);
                TValueTypeName = ((NativeClassWrapper)instance)._safeTypeName;
            }
            else if (typeof(TValue).IsEnum)
            {
                TValueTypeName = typeof(TValue).Namespace switch
                {
                    "Csp" => "csp_",
                    "Csp.Common" => "csp_common_",
                    "Csp.Systems" => "csp_systems_",
                    "Csp.Multiplayer" => "csp_multiplayer_",
                    _ => throw new Exception("Unknown enum namespace!"),
                };
                TValueTypeName += typeof(TValue).Name;
            }
            else
                TValueTypeName = typeof(TValue).Name;

            __safeTypeName = $"csp_common_Map_{TKeyTypeName}_{TValueTypeName}";

            IntPtr ptr;

            ptr = Global.GetFunctionAddress($"csp_common_Map_Ctor_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_Ctor = Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_CtorDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_Ctor_MapRC_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_Ctor_MapRC =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_Ctor_MapRCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_Dtor_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_Dtor = Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_DtorDelegate>(ptr);

            ptr = Global.GetFunctionAddress(
                $"csp_common_Map_op_Index_TValueR_TKeyRC_Get_{TKeyTypeName}_{TValueTypeName}"
            );
            csp_common_Map_op_Index_TValueR_TKeyRC_Get =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_op_Index_TValueR_TKeyRC_GetDelegate>(
                    ptr
                );
            ptr = Global.GetFunctionAddress(
                $"csp_common_Map_op_Index_TValueR_TKeyRC_Set_{TKeyTypeName}_{TValueTypeName}"
            );
            csp_common_Map_op_Index_TValueR_TKeyRC_Set =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_op_Index_TValueR_TKeyRC_SetDelegate>(
                    ptr
                );

            ptr = Global.GetFunctionAddress($"csp_common_Map_SizeC_size_t_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_SizeC_size_t =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_SizeC_size_tDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_HasKeyC_bool_TKeyRC_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_HasKeyC_bool_TKeyRC =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_HasKeyC_bool_TKeyRCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_KeysC_ArrayPC_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_KeysC_ArrayPC =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_KeysC_ArrayPCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_ValuesC_ArrayPC_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_ValuesC_ArrayPC =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_ValuesC_ArrayPCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_Remove_void_TKeyRC_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_Remove_void_TKeyRC =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_Remove_void_TKeyRCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Map_Clear_void_{TKeyTypeName}_{TValueTypeName}");
            csp_common_Map_Clear_void =
                Marshal.GetDelegateForFunctionPointer<MapDelegates.csp_common_Map_Clear_voidDelegate>(ptr);
        }

        internal Map(NativePointer ptr)
        {
            InitialiseNativeDelegates();

            IsTKeyProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(TKey));
            IsTValueProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(TValue));

            _ptr = ptr.Pointer;
            _ownsPtr = ptr.OwnsOwnData;
        }

        public Map()
        {
            InitialiseNativeDelegates();

            IsTKeyProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(TKey));
            IsTValueProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(TValue));

            var np = csp_common_Map_Ctor();
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

        public Map(Csp.Common.Map<TKey, TValue> Other)
        {
            InitialiseNativeDelegates();

            IsTKeyProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(TKey));
            IsTValueProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(TValue));

            var np = csp_common_Map_Ctor_MapRC(Other._ptr);
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

        ~Map()
        {
            //RealDispose();
        }

        void RealDispose()
        {
            if (_ownsPtr && !_disposed)
            {
                csp_common_Map_Dtor(_ptr);
                _disposed = true;
            }

            _disposed = true;
        }

        public void Dispose()
        {
            RealDispose();
            GC.SuppressFinalize(this);
        }

        public TValue this[TKey Key]
        {
            get
            {
                var valuePtr = csp_common_Map_op_Index_TValueR_TKeyRC_Get(
                    _ptr,
                    WrapperHelper.ObjectToIntPtr(Key, IsTKeyProxyClass)
                );

                return (TValue)WrapperHelper.NativePointerToObject<TValue>(valuePtr, IsTValueProxyClass);
            }
            set
            {
                var valuePtr = WrapperHelper.ObjectToIntPtr(value, IsTValueProxyClass);

                csp_common_Map_op_Index_TValueR_TKeyRC_Set(
                    _ptr,
                    WrapperHelper.ObjectToIntPtr(Key, IsTKeyProxyClass),
                    valuePtr
                );
            }
        }

        public ulong Size()
        {
            return csp_common_Map_SizeC_size_t(_ptr);
        }

        public bool HasKey(TKey Key)
        {
            return csp_common_Map_HasKeyC_bool_TKeyRC(_ptr, WrapperHelper.ObjectToIntPtr(Key, IsTKeyProxyClass));
        }

        public Csp.Common.Array<TKey> Keys()
        {
            return new Csp.Common.Array<TKey>(csp_common_Map_KeysC_ArrayPC(_ptr));
        }

        public Csp.Common.Array<TValue> Values()
        {
            return new Csp.Common.Array<TValue>(csp_common_Map_ValuesC_ArrayPC(_ptr));
        }

        public void Remove(TKey Key)
        {
            csp_common_Map_Remove_void_TKeyRC(_ptr, WrapperHelper.ObjectToIntPtr(Key, IsTKeyProxyClass));
        }

        public void Clear()
        {
            csp_common_Map_Clear_void(_ptr);
        }
    }
}

