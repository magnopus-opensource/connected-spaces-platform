// WARNING: DO NOT EDIT THIS FILE! IT IS A GENERATED FILE AND
//   ANY CHANGES YOU MAKE WILL BE OVERWRITTEN ON THE NEXT BUILD

#nullable enable annotations

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

namespace Csp.Common
{
    static class ArrayDelegates
    {
        public delegate NativePointer csp_common_Array_CtorDelegate();
        public delegate NativePointer csp_common_Array_Conv_size_tCDelegate(ulong Size);
        public delegate void csp_common_Array_DtorDelegate(IntPtr @class);
        public delegate NativePointer csp_common_Array_op_Index_TR_size_tC_GetDelegate(IntPtr @class, ulong Index);
        public delegate void csp_common_Array_op_Index_TR_size_tC_SetDelegate(IntPtr @class, ulong Index, IntPtr value);
        public delegate ulong csp_common_Array_SizeC_size_tCDelegate(IntPtr @class);
        public delegate bool csp_common_Array_IsEmptyC_boolDelegate(IntPtr @class);
    }

    public class Array<T> : NativeClassWrapper, IDisposable
    {
        string __safeTypeName;
        internal override string _safeTypeName
        {
            get => __safeTypeName;
        }

        ArrayDelegates.csp_common_Array_CtorDelegate csp_common_Array_Ctor;
        ArrayDelegates.csp_common_Array_Conv_size_tCDelegate csp_common_Array_Conv_size_tC;
        ArrayDelegates.csp_common_Array_DtorDelegate csp_common_Array_Dtor;
        ArrayDelegates.csp_common_Array_op_Index_TR_size_tC_GetDelegate csp_common_Array_op_Index_TR_size_tC_Get;
        ArrayDelegates.csp_common_Array_op_Index_TR_size_tC_SetDelegate csp_common_Array_op_Index_TR_size_tC_Set;
        ArrayDelegates.csp_common_Array_SizeC_size_tCDelegate csp_common_Array_SizeC_size_tC;
        ArrayDelegates.csp_common_Array_IsEmptyC_boolDelegate csp_common_Array_IsEmptyC_bool;

        readonly bool IsTProxyClass;

        void InitialiseNativeDelegates()
        {
            // TODO: Move this stuff into a static dictionary so we don't have to create instances to get the string
            //  eg.
            //  static class TemplateMetadata {
            //    public static Dictionary<Type, string> SafeNames = {
            //      [typeof(Csp.Systems.Anchor)] = "csp_systems_Anchor"
            //    };
            //
            //    /* Delegates here for template instance functions */
            //  }
            const BindingFlags ctorBindingFlags =
                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            var ctorArgs = new object[] { NativePointer.Zero };

            string TTypeName;

            if (typeof(NativeClassWrapper).IsAssignableFrom(typeof(T)))
            {
                var instance = Activator.CreateInstance(typeof(T), ctorBindingFlags, null, ctorArgs, null);
                TTypeName = ((NativeClassWrapper)instance)._safeTypeName;
            }
            else if (typeof(T).IsEnum)
            {
                TTypeName = typeof(T).Namespace switch
                {
                    "Csp" => "csp_",
                    "Csp.Common" => "csp_common_",
                    "Csp.Systems" => "csp_systems_",
                    "Csp.Multiplayer" => "csp_multiplayer_",
                    _ => throw new Exception("Unknown enum namespace!"),
                };
                TTypeName += typeof(T).Name;
            }
            else
                TTypeName = typeof(T).Name;

            __safeTypeName = $"csp_common_Array_{TTypeName}";

            IntPtr ptr;

            ptr = Global.GetFunctionAddress($"csp_common_Array_Ctor_{TTypeName}");
            csp_common_Array_Ctor = Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_CtorDelegate>(
                ptr
            );

            ptr = Global.GetFunctionAddress($"csp_common_Array_Conv_size_tC_{TTypeName}");
            csp_common_Array_Conv_size_tC =
                Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_Conv_size_tCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Array_Dtor_{TTypeName}");
            csp_common_Array_Dtor = Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_DtorDelegate>(
                ptr
            );

            ptr = Global.GetFunctionAddress($"csp_common_Array_op_Index_TR_size_tC_Get_{TTypeName}");
            csp_common_Array_op_Index_TR_size_tC_Get =
                Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_op_Index_TR_size_tC_GetDelegate>(
                    ptr
                );
            ptr = Global.GetFunctionAddress($"csp_common_Array_op_Index_TR_size_tC_Set_{TTypeName}");
            csp_common_Array_op_Index_TR_size_tC_Set =
                Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_op_Index_TR_size_tC_SetDelegate>(
                    ptr
                );

            ptr = Global.GetFunctionAddress($"csp_common_Array_SizeC_size_tC_{TTypeName}");
            csp_common_Array_SizeC_size_tC =
                Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_SizeC_size_tCDelegate>(ptr);

            ptr = Global.GetFunctionAddress($"csp_common_Array_IsEmptyC_bool_{TTypeName}");
            csp_common_Array_IsEmptyC_bool =
                Marshal.GetDelegateForFunctionPointer<ArrayDelegates.csp_common_Array_IsEmptyC_boolDelegate>(ptr);
        }

        internal Array(NativePointer ptr)
        {
            InitialiseNativeDelegates();

            IsTProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(T));

            _ptr = ptr.Pointer;
            _ownsPtr = ptr.OwnsOwnData;
        }

        public Array()
        {
            InitialiseNativeDelegates();

            IsTProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(T));

            var np = csp_common_Array_Ctor();
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

        public Array(ulong Size)
        {
            InitialiseNativeDelegates();

            IsTProxyClass = typeof(NativeClassWrapper).IsAssignableFrom(typeof(T));

            var np = csp_common_Array_Conv_size_tC(Size);
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

        ~Array()
        {
            //RealDispose();
        }

        void RealDispose()
        {
            if (_ownsPtr && !_disposed)
            {
                csp_common_Array_Dtor(_ptr);
                _disposed = true;
            }

            _disposed = true;
        }

        public void Dispose()
        {
            RealDispose();
            GC.SuppressFinalize(this);
        }

        public T this[ulong Index]
        {
            get
            {
                var valuePtr = csp_common_Array_op_Index_TR_size_tC_Get(_ptr, Index);

                return (T)WrapperHelper.NativePointerToObject<T>(valuePtr, IsTProxyClass);
            }
            set
            {
                var valuePtr = WrapperHelper.ObjectToIntPtr(value, IsTProxyClass);

                csp_common_Array_op_Index_TR_size_tC_Set(_ptr, Index, valuePtr);
            }
        }

        public ulong Size()
        {
            return csp_common_Array_SizeC_size_tC(_ptr);
        }

        public bool IsEmpty()
        {
            return csp_common_Array_IsEmptyC_bool(_ptr);
        }
    }
}

