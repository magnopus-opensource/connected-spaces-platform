// WARNING: DO NOT EDIT THIS FILE! IT IS A GENERATED FILE AND
//   ANY CHANGES YOU MAKE WILL BE OVERWRITTEN ON THE NEXT BUILD

#nullable enable annotations

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

namespace Csp.Multiplayer
{
    /// @ingroup Multiplayer
    /// <summary>Handling of all multiplayer connection functionality, such as connect, disconnect, entity replication and network events.</summary>

    public class MultiplayerConnection : NativeClassWrapper, IDisposable
    {
        internal override string _safeTypeName { get; } = "csp_multiplayer_MultiplayerConnection";

        #region P/Invoke
#pragma warning disable IDE1006

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetDisconnectionCallback_void_DisconnectionCallbackHandler(
            IntPtr @class,
            SetDisconnectionCallbackCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetConnectionCallback_void_ConnectionCallbackHandler(
            IntPtr @class,
            SetConnectionCallbackCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetNetworkInterruptionCallback_void_NetworkInterruptionCallbackHandler(
            IntPtr @class,
            SetNetworkInterruptionCallbackCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetAssetDetailBlobChangedCallback_void_AssetDetailBlobChangedCallbackHandler(
            IntPtr @class,
            SetAssetDetailBlobChangedCallbackCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetConversationSystemCallback_void_ConversationSystemCallbackHandler(
            IntPtr @class,
            SetConversationSystemCallbackCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetUserPermissionsChangedCallback_void_UserPermissionsChangedCallbackHandler(
            IntPtr @class,
            SetUserPermissionsChangedCallbackCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_multiplayer_MultiplayerConnection_Ctor_String(string InSpaceId);

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_Dtor(IntPtr @class);

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_multiplayer_MultiplayerConnection_Ctor_MultiplayerConnectionRC(
            IntPtr InBoundConnection
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_Connect_void_ErrorCodeCallbackHandler(
            IntPtr @class,
            ConnectCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_Disconnect_void_ErrorCodeCallbackHandler(
            IntPtr @class,
            DisconnectCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_InitialiseConnection_void_ErrorCodeCallbackHandler(
            IntPtr @class,
            InitialiseConnectionCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SendNetworkEvent_void_StringRC_ArrayRC_ErrorCodeCallbackHandler(
            IntPtr @class,
            string EventName,
            IntPtr Args,
            SendNetworkEventCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SendNetworkEventToClient_void_StringRC_ArrayRC_uint64_t_ErrorCodeCallbackHandler(
            IntPtr @class,
            string EventName,
            IntPtr Args,
            ulong TargetClientId,
            SendNetworkEventToClientCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_ListenNetworkEvent_void_StringRC_ParameterisedCallbackHandler(
            IntPtr @class,
            IntPtr EventName,
            _ListenNetworkEventCallbackDelegate Callback,
            IntPtr CallbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_StopListenNetworkEvent_void_StringRC(
            IntPtr @class,
            IntPtr EventName
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern ulong csp_multiplayer_MultiplayerConnection_GetClientIdC_uint64_t(IntPtr @class);

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_multiplayer_MultiplayerConnection_GetSpaceEntitySystemC_SpaceEntitySystemP(
            IntPtr @class
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_multiplayer_MultiplayerConnection_GetConversationSystemC_ConversationSystemP(
            IntPtr @class
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern Csp.Multiplayer.ConnectionState csp_multiplayer_MultiplayerConnection_GetConnectionStateC_ConnectionState(
            IntPtr @class
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_MultiplayerConnection_SetAllowSelfMessagingFlag_void_boolC_ErrorCodeCallbackHandler(
            IntPtr @class,
            bool AllowSelfMessaging,
            SetAllowSelfMessagingFlagCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern bool csp_multiplayer_MultiplayerConnection_GetAllowSelfMessagingFlagC_bool(IntPtr @class);

#pragma warning restore IDE1006
        #endregion

        internal MultiplayerConnection(NativePointer ptr) : base(ptr) { }

        delegate void ConnectCallbackDelegate(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode arg1);

        delegate void DisconnectCallbackDelegate(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode arg1);

        delegate void InitialiseConnectionCallbackDelegate(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode arg1);

        delegate void SendNetworkEventCallbackDelegate(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode arg1);

        delegate void SendNetworkEventToClientCallbackDelegate(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode arg1);

        delegate void SetDisconnectionCallbackCallbackDelegate(IntPtr _StateObject__, string arg1);

        delegate void SetConnectionCallbackCallbackDelegate(IntPtr _StateObject__, string arg1);

        delegate void SetNetworkInterruptionCallbackCallbackDelegate(IntPtr _StateObject__, string arg1);

        delegate void SetAssetDetailBlobChangedCallbackCallbackDelegate(IntPtr _StateObject__, NativePointer arg1);

        delegate void SetConversationSystemCallbackCallbackDelegate(IntPtr _StateObject__, NativePointer arg1);

        delegate void SetUserPermissionsChangedCallbackCallbackDelegate(IntPtr _StateObject__, NativePointer arg1);

        delegate void _ListenNetworkEventCallbackDelegate(IntPtr _StateObject__, bool arg1, NativePointer arg2);

        public delegate void ListenNetworkEventCallbackDelegate(
            bool arg1,
            Csp.Common.Array<Csp.Multiplayer.ReplicatedValue> arg2
        );
        delegate void SetAllowSelfMessagingFlagCallbackDelegate(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode arg1);

        readonly List<GCHandle> eventHandles = new List<GCHandle>();

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetDisconnectionCallbackCallbackDelegate))]
#endif
        static void SetDisconnectionCallbackCallbackDelegateFunction(IntPtr _StateObject__, string _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var _this = (MultiplayerConnection)_handle.Target;
            _this.RealOnDisconnection?.Invoke(_this, _arg1);
        }

        static readonly SetDisconnectionCallbackCallbackDelegate OnDisconnectionDelegateInstance =
            SetDisconnectionCallbackCallbackDelegateFunction;

        bool OnDisconnectionInitialised = false;
        event EventHandler<string>? RealOnDisconnection;
        public event EventHandler<string> OnDisconnection
        {
            add
            {
                if (!OnDisconnectionInitialised)
                {
                    var handle = GCHandle.Alloc(this);
                    csp_multiplayer_MultiplayerConnection_SetDisconnectionCallback_void_DisconnectionCallbackHandler(
                        _ptr,
                        OnDisconnectionDelegateInstance,
                        (IntPtr)handle
                    );
                    eventHandles.Add(handle);
                    OnDisconnectionInitialised = true;
                }

                RealOnDisconnection += value;
            }
            remove { RealOnDisconnection -= value; }
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetConnectionCallbackCallbackDelegate))]
#endif
        static void SetConnectionCallbackCallbackDelegateFunction(IntPtr _StateObject__, string _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var _this = (MultiplayerConnection)_handle.Target;
            _this.RealOnConnection?.Invoke(_this, _arg1);
        }

        static readonly SetConnectionCallbackCallbackDelegate OnConnectionDelegateInstance =
            SetConnectionCallbackCallbackDelegateFunction;

        bool OnConnectionInitialised = false;
        event EventHandler<string>? RealOnConnection;
        public event EventHandler<string> OnConnection
        {
            add
            {
                if (!OnConnectionInitialised)
                {
                    var handle = GCHandle.Alloc(this);
                    csp_multiplayer_MultiplayerConnection_SetConnectionCallback_void_ConnectionCallbackHandler(
                        _ptr,
                        OnConnectionDelegateInstance,
                        (IntPtr)handle
                    );
                    eventHandles.Add(handle);
                    OnConnectionInitialised = true;
                }

                RealOnConnection += value;
            }
            remove { RealOnConnection -= value; }
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetNetworkInterruptionCallbackCallbackDelegate))]
#endif
        static void SetNetworkInterruptionCallbackCallbackDelegateFunction(IntPtr _StateObject__, string _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var _this = (MultiplayerConnection)_handle.Target;
            _this.RealOnNetworkInterruption?.Invoke(_this, _arg1);
        }

        static readonly SetNetworkInterruptionCallbackCallbackDelegate OnNetworkInterruptionDelegateInstance =
            SetNetworkInterruptionCallbackCallbackDelegateFunction;

        bool OnNetworkInterruptionInitialised = false;
        event EventHandler<string>? RealOnNetworkInterruption;
        public event EventHandler<string> OnNetworkInterruption
        {
            add
            {
                if (!OnNetworkInterruptionInitialised)
                {
                    var handle = GCHandle.Alloc(this);
                    csp_multiplayer_MultiplayerConnection_SetNetworkInterruptionCallback_void_NetworkInterruptionCallbackHandler(
                        _ptr,
                        OnNetworkInterruptionDelegateInstance,
                        (IntPtr)handle
                    );
                    eventHandles.Add(handle);
                    OnNetworkInterruptionInitialised = true;
                }

                RealOnNetworkInterruption += value;
            }
            remove { RealOnNetworkInterruption -= value; }
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetAssetDetailBlobChangedCallbackCallbackDelegate))]
#endif
        static void SetAssetDetailBlobChangedCallbackCallbackDelegateFunction(
            IntPtr _StateObject__,
            NativePointer _arg1
        ) {
            var _handle = (GCHandle)_StateObject__;
            var _this = (MultiplayerConnection)_handle.Target;
            _this.RealOnAssetDetailBlobChanged?.Invoke(_this, new Csp.Multiplayer.AssetDetailBlobParams(_arg1));
        }

        static readonly SetAssetDetailBlobChangedCallbackCallbackDelegate OnAssetDetailBlobChangedDelegateInstance =
            SetAssetDetailBlobChangedCallbackCallbackDelegateFunction;

        bool OnAssetDetailBlobChangedInitialised = false;
        event EventHandler<Csp.Multiplayer.AssetDetailBlobParams>? RealOnAssetDetailBlobChanged;
        public event EventHandler<Csp.Multiplayer.AssetDetailBlobParams> OnAssetDetailBlobChanged
        {
            add
            {
                if (!OnAssetDetailBlobChangedInitialised)
                {
                    var handle = GCHandle.Alloc(this);
                    csp_multiplayer_MultiplayerConnection_SetAssetDetailBlobChangedCallback_void_AssetDetailBlobChangedCallbackHandler(
                        _ptr,
                        OnAssetDetailBlobChangedDelegateInstance,
                        (IntPtr)handle
                    );
                    eventHandles.Add(handle);
                    OnAssetDetailBlobChangedInitialised = true;
                }

                RealOnAssetDetailBlobChanged += value;
            }
            remove { RealOnAssetDetailBlobChanged -= value; }
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetConversationSystemCallbackCallbackDelegate))]
#endif
        static void SetConversationSystemCallbackCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var _this = (MultiplayerConnection)_handle.Target;
            _this.RealOnConversationSystem?.Invoke(_this, new Csp.Multiplayer.ConversationSystemParams(_arg1));
        }

        static readonly SetConversationSystemCallbackCallbackDelegate OnConversationSystemDelegateInstance =
            SetConversationSystemCallbackCallbackDelegateFunction;

        bool OnConversationSystemInitialised = false;
        event EventHandler<Csp.Multiplayer.ConversationSystemParams>? RealOnConversationSystem;
        public event EventHandler<Csp.Multiplayer.ConversationSystemParams> OnConversationSystem
        {
            add
            {
                if (!OnConversationSystemInitialised)
                {
                    var handle = GCHandle.Alloc(this);
                    csp_multiplayer_MultiplayerConnection_SetConversationSystemCallback_void_ConversationSystemCallbackHandler(
                        _ptr,
                        OnConversationSystemDelegateInstance,
                        (IntPtr)handle
                    );
                    eventHandles.Add(handle);
                    OnConversationSystemInitialised = true;
                }

                RealOnConversationSystem += value;
            }
            remove { RealOnConversationSystem -= value; }
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetUserPermissionsChangedCallbackCallbackDelegate))]
#endif
        static void SetUserPermissionsChangedCallbackCallbackDelegateFunction(
            IntPtr _StateObject__,
            NativePointer _arg1
        ) {
            var _handle = (GCHandle)_StateObject__;
            var _this = (MultiplayerConnection)_handle.Target;
            _this.RealOnUserPermissionsChanged?.Invoke(_this, new Csp.Multiplayer.UserPermissionsParams(_arg1));
        }

        static readonly SetUserPermissionsChangedCallbackCallbackDelegate OnUserPermissionsChangedDelegateInstance =
            SetUserPermissionsChangedCallbackCallbackDelegateFunction;

        bool OnUserPermissionsChangedInitialised = false;
        event EventHandler<Csp.Multiplayer.UserPermissionsParams>? RealOnUserPermissionsChanged;
        public event EventHandler<Csp.Multiplayer.UserPermissionsParams> OnUserPermissionsChanged
        {
            add
            {
                if (!OnUserPermissionsChangedInitialised)
                {
                    var handle = GCHandle.Alloc(this);
                    csp_multiplayer_MultiplayerConnection_SetUserPermissionsChangedCallback_void_UserPermissionsChangedCallbackHandler(
                        _ptr,
                        OnUserPermissionsChangedDelegateInstance,
                        (IntPtr)handle
                    );
                    eventHandles.Add(handle);
                    OnUserPermissionsChangedInitialised = true;
                }

                RealOnUserPermissionsChanged += value;
            }
            remove { RealOnUserPermissionsChanged -= value; }
        }

        public MultiplayerConnection(string InSpaceId)
        {
            var np = csp_multiplayer_MultiplayerConnection_Ctor_String(InSpaceId);
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

        ~MultiplayerConnection()
        {
            //RealDispose();
        }

        void RealDispose()
        {
            if (_ownsPtr && !_disposed)
            {
                csp_multiplayer_MultiplayerConnection_Dtor(_ptr);
                _disposed = true;
            }

            _disposed = true;
        }

        public void Dispose()
        {
            RealDispose();
            GC.SuppressFinalize(this);
        }

        public MultiplayerConnection(Csp.Multiplayer.MultiplayerConnection InBoundConnection)
        {
            var np = csp_multiplayer_MultiplayerConnection_Ctor_MultiplayerConnectionRC(InBoundConnection._ptr);
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (ConnectCallbackDelegate))]
#endif
        static void ConnectCallbackDelegateFunction(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ErrorCode>)_handle.Target;
            var _this = (MultiplayerConnection)tcs.Task.AsyncState;

            var task_result = _arg1;

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly ConnectCallbackDelegate ConnectDelegateInstance = ConnectCallbackDelegateFunction;

        /// <summary>Start the connection and register to start receiving updates from the server.</summary>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ErrorCode> Connect()
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ErrorCode>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_MultiplayerConnection_Connect_void_ErrorCodeCallbackHandler(
                _ptr,
                ConnectDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DisconnectCallbackDelegate))]
#endif
        static void DisconnectCallbackDelegateFunction(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ErrorCode>)_handle.Target;
            var _this = (MultiplayerConnection)tcs.Task.AsyncState;

            var task_result = _arg1;

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DisconnectCallbackDelegate DisconnectDelegateInstance = DisconnectCallbackDelegateFunction;

        /// <summary>End the multiplayer connection.</summary>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ErrorCode> Disconnect()
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ErrorCode>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_MultiplayerConnection_Disconnect_void_ErrorCodeCallbackHandler(
                _ptr,
                DisconnectDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (InitialiseConnectionCallbackDelegate))]
#endif
        static void InitialiseConnectionCallbackDelegateFunction(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ErrorCode>)_handle.Target;
            var _this = (MultiplayerConnection)tcs.Task.AsyncState;

            var task_result = _arg1;

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly InitialiseConnectionCallbackDelegate InitialiseConnectionDelegateInstance =
            InitialiseConnectionCallbackDelegateFunction;

        /// <summary>Initialise the connection and get initial entity data from the server.</summary>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ErrorCode> InitialiseConnection()
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ErrorCode>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_MultiplayerConnection_InitialiseConnection_void_ErrorCodeCallbackHandler(
                _ptr,
                InitialiseConnectionDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SendNetworkEventCallbackDelegate))]
#endif
        static void SendNetworkEventCallbackDelegateFunction(IntPtr _StateObject__, Csp.Multiplayer.ErrorCode _arg1)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ErrorCode>)_handle.Target;
            var _this = (MultiplayerConnection)tcs.Task.AsyncState;

            var task_result = _arg1;

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly SendNetworkEventCallbackDelegate SendNetworkEventDelegateInstance =
            SendNetworkEventCallbackDelegateFunction;

        /// <summary>Sends a network event by EventName to all currently connected clients.</summary>
                /// <param name="EventName">The identifying name for the event.</param>
                /// <param name="Args">An array of arguments (ReplicatedValue) to be passed as part of the event payload.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ErrorCode> SendNetworkEvent(
            string EventName,
            Csp.Common.Array<Csp.Multiplayer.ReplicatedValue> Args
        ) {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ErrorCode>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_MultiplayerConnection_SendNetworkEvent_void_StringRC_ArrayRC_ErrorCodeCallbackHandler(
                _ptr,
                EventName,
                Args._ptr,
                SendNetworkEventDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SendNetworkEventToClientCallbackDelegate))]
#endif
        static void SendNetworkEventToClientCallbackDelegateFunction(
            IntPtr _StateObject__,
            Csp.Multiplayer.ErrorCode _arg1
        ) {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ErrorCode>)_handle.Target;
            var _this = (MultiplayerConnection)tcs.Task.AsyncState;

            var task_result = _arg1;

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly SendNetworkEventToClientCallbackDelegate SendNetworkEventToClientDelegateInstance =
            SendNetworkEventToClientCallbackDelegateFunction;

        /// <summary>Sends a network event by EventName, to TargetClientId.</summary>
                /// <param name="EventName">The identifying name for the event.</param>
                /// <param name="Args">An array of arguments (ReplicatedValue) to be passed as part of the event payload.</param>
                /// <param name="TargetClientId">The client ID to send the event to.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ErrorCode> SendNetworkEventToClient(
            string EventName,
            Csp.Common.Array<Csp.Multiplayer.ReplicatedValue> Args,
            ulong TargetClientId
        ) {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ErrorCode>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_MultiplayerConnection_SendNetworkEventToClient_void_StringRC_ArrayRC_uint64_t_ErrorCodeCallbackHandler(
                _ptr,
                EventName,
                Args._ptr,
                TargetClientId,
                SendNetworkEventToClientDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

        /// <summary>Registers a callback to listen for the named event.</summary>
        /// <param name="EventName">The identifying name for the event to listen for.</param>
        /// <param name="Callback">A callback to register for the event which contains the parameter payload data.</param>

        static void ListenNetworkEventCallbackDelegateFunction(IntPtr _StateObject__, bool arg1, NativePointer arg2)
        {
            var _handle = (GCHandle)_StateObject__;
            var _Callback = (ListenNetworkEventCallbackDelegate)_handle.Target;

            var _arg1 = arg1;
            var _arg2 = new Csp.Common.Array<Csp.Multiplayer.ReplicatedValue>(arg2);

            _Callback(_arg1, _arg2);
            // TODO: Queue persistent callback handles to be freed on exit
            // _handle.Free();
        }

        public void ListenNetworkEvent(string EventName, ListenNetworkEventCallbackDelegate Callback)
        {
            var _Callback = GCHandle.Alloc(Callback);

            csp_multiplayer_MultiplayerConnection_ListenNetworkEvent_void_StringRC_ParameterisedCallbackHandler(
                _ptr,
                WrapperHelper.StringToNativeUTF8(EventName),
                ListenNetworkEventCallbackDelegateFunction,
                (IntPtr)_Callback
            );
        }

        /// <summary>Stops the multiplayer connection from listening for a particular network event.</summary>
        /// <param name="EventName">The identifying name for the event to stop listening for.</param>


        public void StopListenNetworkEvent(string EventName)
        {
            csp_multiplayer_MultiplayerConnection_StopListenNetworkEvent_void_StringRC(
                _ptr,
                WrapperHelper.StringToNativeUTF8(EventName)
            );
        }

        /// <summary>Requests the ClientID.</summary>
        /// <returns>Uint64_t the clientid for this connection.</returns>


        public ulong GetClientId()
        {
            var _result = csp_multiplayer_MultiplayerConnection_GetClientIdC_uint64_t(_ptr);

            return _result;
        }

        /// <summary>Gets a pointer to the space entity system.</summary>
        /// <returns>A pointer to the space entity system.</returns>


        public Csp.Multiplayer.SpaceEntitySystem GetSpaceEntitySystem()
        {
            var _result = new Csp.Multiplayer.SpaceEntitySystem(
                csp_multiplayer_MultiplayerConnection_GetSpaceEntitySystemC_SpaceEntitySystemP(_ptr)
            );

            return _result;
        }

        /// <summary>Gets a pointer to the conversation system.</summary>
        /// <returns>A pointer to the conversation system.</returns>


        public Csp.Multiplayer.ConversationSystem GetConversationSystem()
        {
            var _result = new Csp.Multiplayer.ConversationSystem(
                csp_multiplayer_MultiplayerConnection_GetConversationSystemC_ConversationSystemP(_ptr)
            );

            return _result;
        }

        /// <summary>Gets the current connection state.</summary>
        /// <returns>A ConnectionState enum value.</returns>


        public Csp.Multiplayer.ConnectionState GetConnectionState()
        {
            var _result = csp_multiplayer_MultiplayerConnection_GetConnectionStateC_ConnectionState(_ptr);

            return _result;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetAllowSelfMessagingFlagCallbackDelegate))]
#endif
        static void SetAllowSelfMessagingFlagCallbackDelegateFunction(
            IntPtr _StateObject__,
            Csp.Multiplayer.ErrorCode _arg1
        ) {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ErrorCode>)_handle.Target;
            var _this = (MultiplayerConnection)tcs.Task.AsyncState;

            var task_result = _arg1;

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly SetAllowSelfMessagingFlagCallbackDelegate SetAllowSelfMessagingFlagDelegateInstance =
            SetAllowSelfMessagingFlagCallbackDelegateFunction;

        /// <summary>Sets the Self Messaging flag for this client.</summary>
                /// <remarks>This allows a client to declare that it wishes to recieve every patch and object message it sends.</remarks>
                /// @warning Don't use this function if you aren't sure of the consequences, it's very unlikely that a client would want to use this!
                /// <param name="AllowSelfMessaging">True to allow and false to disallow.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ErrorCode> SetAllowSelfMessagingFlag(bool AllowSelfMessaging)
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ErrorCode>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_MultiplayerConnection_SetAllowSelfMessagingFlag_void_boolC_ErrorCodeCallbackHandler(
                _ptr,
                AllowSelfMessaging,
                SetAllowSelfMessagingFlagDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

        /// <summary>Gets the bool representing if we're using self-messaging or not.</summary>
        /// <returns>True if self messaging is allowed, false otherwise.</returns>


        public bool GetAllowSelfMessagingFlag()
        {
            var _result = csp_multiplayer_MultiplayerConnection_GetAllowSelfMessagingFlagC_bool(_ptr);

            return _result;
        }
    }
}

