// WARNING: DO NOT EDIT THIS FILE! IT IS A GENERATED FILE AND
//   ANY CHANGES YOU MAKE WILL BE OVERWRITTEN ON THE NEXT BUILD

#nullable enable annotations

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;

namespace Csp.Multiplayer
{
    /// @ingroup Conversation System
    /// <summary>Public facing system that can handle conversations taking place between users of a space in the form of thread messages.</summary>

    public class ConversationSystem : NativeClassWrapper
    {
        internal override string _safeTypeName { get; } = "csp_multiplayer_ConversationSystem";

        #region P/Invoke
#pragma warning disable IDE1006



        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern NativePointer csp_multiplayer_ConversationSystem_Ctor_MultiplayerConnectionP(
            IntPtr InMultiPlayerConnection
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_CreateConversation_void_StringRC_StringResultCallback(
            IntPtr @class,
            string Message,
            CreateConversationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_AddMessageToConversation_void_StringRC_StringRC_StringRC_MessageResultCallback(
            IntPtr @class,
            string ConversationId,
            string SenderDisplayName,
            string Message,
            AddMessageToConversationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_GetMessagesFromConversation_void_StringRC_intRC_intRC_MessageCollectionResultCallback(
            IntPtr @class,
            string ConversationId,
            IntPtr ResultsSkipNumber,
            IntPtr ResultsMaxNumber,
            GetMessagesFromConversationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_GetConversationInformation_void_StringRC_ConversationResultCallback(
            IntPtr @class,
            string ConversationId,
            GetConversationInformationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_SetConversationInformation_void_StringRC_ConversationInfoRC_ConversationResultCallback(
            IntPtr @class,
            string ConversationId,
            IntPtr ConversationData,
            SetConversationInformationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_GetMessage_void_StringRC_MessageResultCallback(
            IntPtr @class,
            string MessageId,
            GetMessageCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_SetMessageInformation_void_StringRC_MessageInfoRC_MessageResultCallback(
            IntPtr @class,
            string MessageId,
            IntPtr MessageData,
            SetMessageInformationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_GetMessageInformation_void_StringRC_MessageResultCallback(
            IntPtr @class,
            string MessageId,
            GetMessageInformationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_DeleteConversation_void_StringRC_NullResultCallback(
            IntPtr @class,
            string ConversationId,
            DeleteConversationCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_DeleteMessage_void_StringRC_NullResultCallback(
            IntPtr @class,
            string MessageId,
            DeleteMessageCallbackDelegate callback,
            IntPtr callbackStateObject
        );

        [
            DllImport(
#if !UNITY_EDITOR && UNITY_IOS
            "__Internal"
#elif DEBUG && !UNITY_EDITOR_OSX && !UNITY_STANDALONE_OSX
                "ConnectedSpacesPlatform_D"
#else
                "ConnectedSpacesPlatform"
#endif
            ),
            SuppressUnmanagedCodeSecurity
        ]
        static extern void csp_multiplayer_ConversationSystem_Dtor(IntPtr @class);

#pragma warning restore IDE1006
        #endregion

        internal ConversationSystem(NativePointer ptr) : base(ptr) { }

        delegate void CreateConversationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void AddMessageToConversationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetMessagesFromConversationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetConversationInformationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void SetConversationInformationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetMessageCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void SetMessageInformationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void GetMessageInformationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void DeleteConversationCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        delegate void DeleteMessageCallbackDelegate(IntPtr _StateObject__, NativePointer Result);

        /// <summary>Constructs a conversation system instance that uses the given multiplayer connection.</summary>
        /// <param name="InMultiPlayerConnection">The connection to be used.</param>

        public ConversationSystem(Csp.Multiplayer.MultiplayerConnection InMultiPlayerConnection)
        {
            var np = csp_multiplayer_ConversationSystem_Ctor_MultiplayerConnectionP(InMultiPlayerConnection._ptr);
            _ptr = np.Pointer;
            _ownsPtr = np.OwnsOwnData;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (CreateConversationCallbackDelegate))]
#endif
        static void CreateConversationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.StringResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.StringResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly CreateConversationCallbackDelegate CreateConversationDelegateInstance =
            CreateConversationCallbackDelegateFunction;

        /// <summary>Creates a new conversation with the initial message and provides the conversation ID to the given callback.</summary>
                /// <param name="Message">The message to be stored.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.StringResult> CreateConversation(string Message)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.StringResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_CreateConversation_void_StringRC_StringResultCallback(
                _ptr,
                Message,
                CreateConversationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (AddMessageToConversationCallbackDelegate))]
#endif
        static void AddMessageToConversationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.MessageResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.MessageResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly AddMessageToConversationCallbackDelegate AddMessageToConversationDelegateInstance =
            AddMessageToConversationCallbackDelegateFunction;

        /// <summary>Adds a message to a brand new conversation or to an already existing one</summary>
                /// <remarks>/// Make sure that the user has entered a space through SpaceSystem::EnterSpace() before calling this.</remarks>
                /// <remarks>Sends a network event acknowledgement that can be listened for called "ConversationSystem" containing:</remarks>
                /// <remarks>{ConversationSystemParams of type ReplicatedType : ConversationMessageType::NewMessage, ConversationId of type ReplicatedType : String}.</remarks>
                /// <remarks>/// @param ConversationId csp::common::String : A new message will be linked to the provided conversation id.</remarks>
                /// <param name="SenderDisplayName">The display name of the message sender.</param>
                /// <param name="Message">The message to be stored.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.MessageResult> AddMessageToConversation(
            string ConversationId,
            string SenderDisplayName,
            string Message
        ) {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.MessageResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_AddMessageToConversation_void_StringRC_StringRC_StringRC_MessageResultCallback(
                _ptr,
                ConversationId,
                SenderDisplayName,
                Message,
                AddMessageToConversationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetMessagesFromConversationCallbackDelegate))]
#endif
        static void GetMessagesFromConversationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.MessageCollectionResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.MessageCollectionResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetMessagesFromConversationCallbackDelegate GetMessagesFromConversationDelegateInstance =
            GetMessagesFromConversationCallbackDelegateFunction;

        /// <summary>Retrieves messages that are linked to the provided Conversation ID.</summary>
                /// <param name="ConversationId">Conversation ID.</param>
                /// <param name="ResultsSkipNumber">Optional parameter representing the number of result entries that will be skipped from the result.</param>
                /// <remarks>For no skip pass nullptr.</remarks>
                /// <param name="ResultsMaxNumber">Optional parameter representing the maximum number of result entries to be retrieved. For all</param>
                /// <remarks>available result entries pass nullptr.</remarks>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.MessageCollectionResult> GetMessagesFromConversation(
            string ConversationId,
            int? ResultsSkipNumber,
            int? ResultsMaxNumber
        ) {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.MessageCollectionResult>(this);
            var handle = GCHandle.Alloc(tcs);

            var ResultsSkipNumberPointer = IntPtr.Zero;
            unsafe
            {
                if (ResultsSkipNumber.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = ResultsSkipNumber.Value;
                    ResultsSkipNumberPointer = (IntPtr)ptr;
                }
            }
            var ResultsMaxNumberPointer = IntPtr.Zero;
            unsafe
            {
                if (ResultsMaxNumber.HasValue)
                {
                    var ptr = stackalloc int[1];
                    *ptr = ResultsMaxNumber.Value;
                    ResultsMaxNumberPointer = (IntPtr)ptr;
                }
            }

            csp_multiplayer_ConversationSystem_GetMessagesFromConversation_void_StringRC_intRC_intRC_MessageCollectionResultCallback(
                _ptr,
                ConversationId,
                ResultsSkipNumberPointer,
                ResultsMaxNumberPointer,
                GetMessagesFromConversationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetConversationInformationCallbackDelegate))]
#endif
        static void GetConversationInformationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ConversationResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.ConversationResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetConversationInformationCallbackDelegate GetConversationInformationDelegateInstance =
            GetConversationInformationCallbackDelegateFunction;

        /// <summary>Retrieves the conversation information.</summary>
                /// <param name="ConversationId">Conversation ID.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ConversationResult> GetConversationInformation(string ConversationId)
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ConversationResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_GetConversationInformation_void_StringRC_ConversationResultCallback(
                _ptr,
                ConversationId,
                GetConversationInformationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetConversationInformationCallbackDelegate))]
#endif
        static void SetConversationInformationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.ConversationResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.ConversationResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly SetConversationInformationCallbackDelegate SetConversationInformationDelegateInstance =
            SetConversationInformationCallbackDelegateFunction;

        /// <summary>Sets the conversation information.</summary>
                /// <param name="ConversationId">Conversation ID.</param>
                /// <param name="ConversationData">Conversation Data.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.ConversationResult> SetConversationInformation(
            string ConversationId,
            Csp.Multiplayer.ConversationInfo ConversationData
        ) {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.ConversationResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_SetConversationInformation_void_StringRC_ConversationInfoRC_ConversationResultCallback(
                _ptr,
                ConversationId,
                ConversationData._ptr,
                SetConversationInformationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetMessageCallbackDelegate))]
#endif
        static void GetMessageCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.MessageResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.MessageResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetMessageCallbackDelegate GetMessageDelegateInstance = GetMessageCallbackDelegateFunction;

        /// <summary>Retrieves one particular message.</summary>
                /// <param name="MessageId">ID of the message to be retrieved.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.MessageResult> GetMessage(string MessageId)
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.MessageResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_GetMessage_void_StringRC_MessageResultCallback(
                _ptr,
                MessageId,
                GetMessageDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (SetMessageInformationCallbackDelegate))]
#endif
        static void SetMessageInformationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.MessageResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.MessageResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly SetMessageInformationCallbackDelegate SetMessageInformationDelegateInstance =
            SetMessageInformationCallbackDelegateFunction;

        /// <summary>Sets the message information.</summary>
                /// <param name="MessageId">ID of the message to be retrieved.</param>
                /// <param name="MessageData">Message Data.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.MessageResult> SetMessageInformation(
            string MessageId,
            Csp.Multiplayer.MessageInfo MessageData
        ) {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.MessageResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_SetMessageInformation_void_StringRC_MessageInfoRC_MessageResultCallback(
                _ptr,
                MessageId,
                MessageData._ptr,
                SetMessageInformationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (GetMessageInformationCallbackDelegate))]
#endif
        static void GetMessageInformationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Multiplayer.MessageResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Multiplayer.MessageResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly GetMessageInformationCallbackDelegate GetMessageInformationDelegateInstance =
            GetMessageInformationCallbackDelegateFunction;

        /// <summary>Retrieves the message information.</summary>
                /// <param name="MessageId">Message ID.</param>
                /// <returns>The result for the request</returns>

        public Task<Csp.Multiplayer.MessageResult> GetMessageInformation(string MessageId)
        {
            var tcs = new TaskCompletionSource<Csp.Multiplayer.MessageResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_GetMessageInformation_void_StringRC_MessageResultCallback(
                _ptr,
                MessageId,
                GetMessageInformationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DeleteConversationCallbackDelegate))]
#endif
        static void DeleteConversationCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.NullResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.NullResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DeleteConversationCallbackDelegate DeleteConversationDelegateInstance =
            DeleteConversationCallbackDelegateFunction;

        /// <summary>Deletes all the messages that are part of the conversation.</summary>
                /// <remarks>/// Sends a network event acknowledgement that can be listened for called "ConversationSystem" containing:</remarks>
                /// <remarks>{ConversationSystemParams of type ReplicatedType : ConversationMessageType::DeleteConversation, ConversationId of type ReplicatedType :</remarks>
                /// <remarks>String}.</remarks>
                /// <remarks>/// @param ConversationId csp::common::String : ID of the conversation that will be deleted. After this operation finishes successful this ID will</remarks>
                /// <remarks>not be valid anymore.</remarks>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.NullResult> DeleteConversation(string ConversationId)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.NullResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_DeleteConversation_void_StringRC_NullResultCallback(
                _ptr,
                ConversationId,
                DeleteConversationDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

#if !UNITY_EDITOR && ENABLE_IL2CPP
        [AOT.MonoPInvokeCallback (typeof (DeleteMessageCallbackDelegate))]
#endif
        static void DeleteMessageCallbackDelegateFunction(IntPtr _StateObject__, NativePointer _Result)
        {
            var _handle = (GCHandle)_StateObject__;
            var tcs = (TaskCompletionSource<Csp.Systems.NullResult>)_handle.Target;
            var _this = (ConversationSystem)tcs.Task.AsyncState;

            var task_result = new Csp.Systems.NullResult(_Result);

            if (task_result.GetResultCode() == Csp.Systems.EResultCode.InProgress)
            {
                return;
            }

            tcs.SetResult(task_result);
            _handle.Free();
        }

        static readonly DeleteMessageCallbackDelegate DeleteMessageDelegateInstance =
            DeleteMessageCallbackDelegateFunction;

        /// <summary>Deletes a particular message.</summary>
                /// <remarks>/// Sends a network event acknowledgement that can be listened for called "ConversationSystem" containing:</remarks>
                /// <remarks>{ ConversationSystemParams of type ReplicatedType : ConversationMessageType::DeleteMessage, MessageId of type ReplicatedType : String }.</remarks>
                /// <remarks>/// @param MessageId csp::common::String : ID of the message that will be deleted.</remarks>
                /// <returns>The result for the request</returns>

        public Task<Csp.Systems.NullResult> DeleteMessage(string MessageId)
        {
            var tcs = new TaskCompletionSource<Csp.Systems.NullResult>(this);
            var handle = GCHandle.Alloc(tcs);

            csp_multiplayer_ConversationSystem_DeleteMessage_void_StringRC_NullResultCallback(
                _ptr,
                MessageId,
                DeleteMessageDelegateInstance,
                (IntPtr)handle
            );

            return tcs.Task;
        }

        ~ConversationSystem()
        {
            //RealDispose();
        }

        void RealDispose()
        {
            if (_ownsPtr && !_disposed)
            {
                csp_multiplayer_ConversationSystem_Dtor(_ptr);
                _disposed = true;
            }

            _disposed = true;
        }

        public void Dispose()
        {
            RealDispose();
            GC.SuppressFinalize(this);
        }
    }
}

